<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <!-- Meta Tags -->
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="application-name" content="JhonFs" />
    <meta
      name="description"
      content="Análise e resumo do Capítulo 1 do SICP: Os elementos da programação, processos recursivos vs iterativos, ordens de crescimento e procedimentos de ordem superior."
    />

    <!-- Open Graph / Twitter Meta Tags -->
    <meta
      property="og:title"
      content="Construindo Abstrações com Procedimentos (SICP Cap 1) - Jhonfs"
    />
    <meta
      property="og:description"
      content="Análise e resumo do Capítulo 1 do SICP: Os elementos da programação, processos recursivos vs iterativos, ordens de crescimento e procedimentos de ordem superior."
    />
    <meta property="og:type" content="article" />
    <meta
      property="og:url"
      content="https://jhonfs.com/pt/sicp-capitulo-1-abstracoes-procedimentos.html"
    />
    <meta
      property="og:image"
      content="https://jhonfs.com/img/favicon-96x96.png"
    />
    <meta
      property="article:published_time"
      content="2025-04-28T22:00:00-03:00"
    />
    <meta property="article:author" content="Jhonata Flores Sande" />
    <meta name="twitter:card" content="summary_large_image" />

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/png"
      href="/img/favicon/favicon-96x96.png"
      sizes="96x96"
    />
    <link rel="icon" type="image/svg+xml" href="/img/favicon/favicon.svg" />
    <link rel="shortcut icon" href="/img/favicon/favicon.ico" />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/img/favicon/apple-touch-icon.png"
    />
    <meta name="apple-mobile-web-app-title" content="JhonFs" />
    <link rel="manifest" href="/img/favicon/site.webmanifest" />

    <!-- CSS -->
    <link rel="stylesheet" href="/css/normalize.css" />
    <link rel="stylesheet" href="/css/icons.css" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/article.css" />
    <link rel="stylesheet" href="/css/highlight.css" />
    <link rel="stylesheet" href="/css/sidebar.css" />

    <!-- Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap"
      rel="stylesheet"
    />

    <!-- Script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>

    <!---->
    <title>
      Construindo Abstrações com Procedimentos (SICP Cap 1) - Jhonfs
    </title>
  </head>
  <body>
    <button id="back-to-top" class="back-to-top" aria-label="Voltar ao topo">
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <polyline points="18 15 12 9 6 15"></polyline>
      </svg>
    </button>

    <button
      id="go-to-bottom"
      class="go-to-bottom"
      aria-label="Ir para o final da página"
    >
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <polyline points="6 9 12 15 18 9"></polyline>
      </svg>
    </button>

    <input type="checkbox" id="menu-toggle" class="menu-toggle" />

    <div class="layout-container">
      <label
        for="menu-toggle"
        class="menu-toggle-button"
        aria-label="Abrir menu de navegação"
      >
        <span></span>
        <span></span>
        <span></span>
      </label>

      <aside class="sidebar">
        <div class="sidebar-content">
          <div class="sidebar-section buttons">
            <ul>
              <li>
                <a
                  href="/"
                  target="_self"
                  rel="noopener noreferrer"
                  class="icon icon_home"
                  aria-label="Home"
                >
                  <span class="visually-hidden">Jhonfs</span>
                </a>
              </li>
              <li>
                <button
                  id="theme-toggle"
                  class="theme-toggle-button"
                  aria-label="Alternar tema"
                >
                  <span class="visually-hidden">Alternar tema</span>
                </button>
              </li>
              <li>
                <a
                  href="https://github.com/Jhonatafs"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="icon icon_github"
                  aria-label="GitHub"
                >
                  <span class="visually-hidden">GitHub</span>
                </a>
              </li>
              <li>
                <a
                  href="https://www.linkedin.com/in/jhonataflores/"
                  target="_blank"
                  rel="noopener noreferrer"
                  class="icon icon_linkedin"
                  aria-label="LinkedIn"
                >
                  <span class="visually-hidden">LinkedIn</span>
                </a>
              </li>
            </ul>
          </div>

          <div class="sidebar-section table-of-contents">
            <h4>Navegação</h4>
            <ul id="toc-list">
              <li>
                <a href="#construindo-abstrações-com-procedimentos."
                  >Construindo Abstrações com Procedimentos.</a
                >
                <ul>
                  <li>
                    <a
                      href="#os-elementos-da-programação-os-blocos-de-construção"
                      >Os Elementos da Programação: Os Blocos de Construção</a
                    >
                    <ul>
                      <li>
                        <a
                          href="#expressões-primitivas-os-léptons-da-computação"
                          >Expressões Primitivas: Os Léptons da Computação</a
                        >
                      </li>
                      <li>
                        <a href="#meios-de-combinação-juntando-as-peças"
                          >Meios de Combinação: Juntando as Peças</a
                        >
                      </li>
                      <li>
                        <a href="#meios-de-abstração-dando-nomes-às-coisas"
                          >Meios de Abstração: Dando Nomes às Coisas</a
                        >
                      </li>
                      <li>
                        <a href="#a-mágica-acontece">A Mágica Acontece</a>
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a href="#procedimentos-e-os-processos-que-eles-geram"
                      >Procedimentos e os Processos que Eles Geram</a
                    >
                    <ul>
                      <li>
                        <a href="#a-forma-dos-processos-linear-e-iterativo"
                          >A Forma dos Processos: Linear e Iterativo</a
                        >
                      </li>
                      <li>
                        <a
                          href="#recursão-em-árvore-quando-o-processo-se-ramifica"
                          >Recursão em Árvore: Quando o Processo se Ramifica</a
                        >
                      </li>
                      <li>
                        <a
                          href="#a-ordem-do-caos-ou-da-eficiência-ordens-de-crescimento"
                          >A Ordem do Caos (ou da Eficiência): Ordens de
                          Crescimento</a
                        >
                      </li>
                    </ul>
                  </li>
                  <li>
                    <a
                      href="#formulando-abstrações-com-procedimentos-de-ordem-superior"
                      >Formulando Abstrações com Procedimentos de Ordem
                      Superior</a
                    >
                    <ul>
                      <li>
                        <a
                          href="#procedimentos-como-argumentos-a-fábrica-de-ideias-comuns"
                          >Procedimentos como Argumentos: A Fábrica de Ideias
                          Comuns</a
                        >
                      </li>
                      <li>
                        <a href="#lambda-procedimentos-anônimos-na-hora-h"
                          >Lambda: Procedimentos Anônimos na Hora H</a
                        >
                      </li>
                      <li>
                        <a
                          href="#procedimentos-como-métodos-gerais-a-essência-da-ciência-da-computação"
                          >Procedimentos como Métodos Gerais: A Essência da
                          Ciência da Computação</a
                        >
                      </li>
                      <li>
                        <a href="#a-abstração-de-poder-máximo"
                          >A Abstração de Poder Máximo</a
                        >
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </div>
        </div>
      </aside>
    </div>

    <main class="site-main">
      <div class="container article-container">
        <article class="full-article">
          <header class="article-header">
            <h1 id="construindo-abstrações-com-procedimentos.">
              Construindo Abstrações com Procedimentos.
            </h1>
            <p class="subtitle">
              <em
                >Structure and Interpretation of Computer Programs, capítulo
                1</em
              >
            </p>
            <p class="article-meta">
              Publicado em
              <time datetime="2025-04-28">28 de Abril de 2025</time> por Jhonata
              Flores Sande
            </p>
            <a href="/" class="back-link"
              >&larr; Voltar para a página inicial</a
            >
          </header>

          <p>
            Este capítulo, em particular, me fez perceber lacunas no meu
            conhecimento de matemática, o que me levou a dedicar tempo para
            revisitá-la (utilizando o Khan Academy, por exemplo). Essa jornada
            extra foi fundamental para solidificar alguns entendimentos. Além do
            background matemático, é crucial abordar a leitura com calma e
            atenção. Afinal, trata-se de um livro técnico e denso que pressupõe
            uma base em lógica e, eventualmente, familiaridade com a linguagem
            utilizada.
          </p>
          <p>
            Esse capítulo tem como objetivo introduzir os conceitos fundamentais
            e, utilizando a linguagem Scheme (um dialeto LISP), estabelecer a
            ideia central de um processo computacional. Ele nos mostra como
            programas podem ser vistos como conjuntos de regras que governam a
            forma como esses processos evoluem e manipulam dados.
          </p>
          <blockquote>
            <p>
              <em
                >Uma linguagem de programação poderosa serve não apenas para
                instruir o computador, mas também como estrutura para a
                organização de ideias sobre processos.</em
              >
            </p>
          </blockquote>

          <h2 id="os-elementos-da-programação-os-blocos-de-construção">
            Os Elementos da Programação: Os Blocos de Construção
          </h2>
          <p>
            Depois de ter aquele momento de epifania (ou de dar de cara com a
            parede da matemática!) no começo do capítulo, o SICP, lá no tópico
            <a
              href="https://jhonatafs.github.io/sicp-pt-br/html/1_002e1.html#g_t1_002e1"
              target="_blank"
              rel="noopener noreferrer"
              >1.1</a
            >, começa a mostrar as cartas: quais são as ferramentas básicas que
            qualquer linguagem de programação realmente poderosa te dá para você
            começar a construir o que quiser. É como um kit básico de
            sobrevivência do programador.
          </p>
          <p>
            O livro diz que são três mecanismos essenciais, os quais permitem
            que ideias simples, tonem-se ideias complexas e compostas. Os
            mecanismos são:
          </p>
          <ol>
            <li><strong>Expressões Primitivas</strong></li>
            <li><strong>Meios de Combinação</strong></li>
            <li><strong>Meios de Abstração</strong></li>
          </ol>
          <p>Vamos quebrar cada um desses:</p>

          <h3 id="expressões-primitivas-os-léptons-da-computação">
            Expressões Primitivas: Os Léptons da Computação
          </h3>
          <p>
            Pensa nos Léptons na física. Aquelas partículas que são a menor
            unidade que a gente conhece, que não dá para dividir mais e que,
            combinadas de jeitos diferentes, formam
            <em>tudo</em> que a gente vê e sente – elétrons, neutrinos, e daí
            para frente, construindo átomos, moléculas, a gente, as ideias… É o
            bloco de construção fundamental.
          </p>
          <p>
            Na programação, a <strong>expressão primitiva</strong> tem essa
            mesma pegada. São os elementos mais básicos e “indivisíveis” da
            linguagem. No Scheme, isso pode ser:
          </p>
          <ul>
            <li>
              <strong>Valores literais:</strong> Números (<code>5</code>,
              <code>3.14</code>), textos (<code>"Olá Mundo"</code>), valores
              verdade/falso (<code>#t</code> para verdadeiro,
              <code>#f</code> para falso). São eles mesmos, diretos.
            </li>
            <li>
              <strong>Nomes (ou variáveis):</strong> Identificadores que a gente
              usa para se referir a um valor guardado em algum lugar. Tipo
              <code>pi</code> para 3.14159.
            </li>
          </ul>
          <p>
            O livro também meio que coloca os procedimentos básicos (as
            operações como soma, subtração, etc.) nesse balaio de primitivas
            iniciais, que você pode simplesmente usar. A gente “chama” esses de
            procedimentos primitivos.
          </p>
          <p>
            A ideia é: com esses pedacinhos, você já tem a base. A
            matéria-prima.
          </p>

          <h3 id="meios-de-combinação-juntando-as-peças">
            Meios de Combinação: Juntando as Peças
          </h3>
          <p>
            Agora, ter só os léptons não faz um universo, né? Você precisa de um
            jeito de juntar eles. É aí que entram os
            <strong>meios de combinação</strong>. Eles são as regras ou a
            sintaxe da linguagem que te permitem pegar essas expressões
            primitivas (ou as coisas que você já combinou) e fazer estruturas
            <em>maiores e mais complexas</em>.
          </p>
          <p>
            No Scheme, o jeito clássico de combinar é pela
            <strong>aplicação de um procedimento aos seus argumentos</strong>.
            Aquela notação com parênteses que a gente vê e acha estranho no
            começo:
          </p>
          <pre><code class="language-scheme">(+ 2 3)
;; Combina o procedimento '+' com os números 2 e 3</code></pre>
          <p>
            Isso é uma combinação! Estamos “combinando” o procedimento de soma
            com os números 2 e 3. O resultado dessa combinação é 5.
          </p>
          <p>A gente pode combinar combinações!</p>
          <pre><code class="language-scheme">(* (+ 2 3) 4)
; Combina o procedimento '*' com o resultado de (+ 2 3) e o número 4</code></pre>
          <p>
            Aqui, a combinação <code>(+ 2 3)</code> é usada como parte de outra
            combinação. É como formar moléculas a partir de átomos, e depois
            estruturas maiores a partir dessas moléculas. Os meios de combinação
            são essa “cola”, as regras de sintaxe que permitem construir
            expressões complexas a partir de outras mais simples, definindo a
            <em>estrutura</em> da sua computação.
          </p>

          <h3 id="meios-de-abstração-dando-nomes-às-coisas">
            Meios de Abstração: Dando Nomes às Coisas
          </h3>
          <p>
            Ter um monte de estruturas combinadas é legal, mas e se você quiser
            usar a mesma estrutura várias vezes sem ter que escrever tudo de
            novo? Ou se você quiser se referir a uma ideia complexa por um nome
            simples? É para isso que servem os
            <strong>meios de abstração</strong>.
          </p>
          <p>
            O meio de abstração mais básico no SICP
            <a
              href="https://jhonatafs.github.io/sicp-pt-br/html/1_002e1.html#g_t1_002e1"
              target="_blank"
              rel="noopener noreferrer"
              >1.1</a
            >
            é simplesmente <strong>dar um nome a alguma coisa</strong>. No
            Scheme, a gente faz isso principalmente com o <code>define</code>:
          </p>
          <pre><code class="language-scheme">(define tamanho 10)
; Dá o nome 'tamanho' para o valor 10</code></pre>
          <p>
            Agora, em vez de usar sempre <code>10</code>, eu posso usar
            <code>tamanho</code>. Eu criei uma <em>abstração</em>. Eu encapsulei
            o valor 10 sob um nome que talvez diga algo sobre o que ele
            representa.
          </p>
          <p>
            A gente também usa <code>define</code> para dar nome a procedimentos
            que a gente cria:
          </p>
          <pre><code class="language-scheme">(define (quadrado x) (* x x))
; Dá o nome 'quadrado' para um procedimento que multiplica seu argumento por ele mesmo</code></pre>
          <p>
            Pronto! Criei uma abstração para a ideia de “elevar ao quadrado”.
            Agora eu posso simplesmente usar
            <code>(quadrado 5)</code> em vez de escrever <code>(* 5 5)</code>.
          </p>
          <p>
            E é aqui que entra a ideia da “Caixa Preta”. Uma vez que a gente
            define um procedimento e dá um nome para ele, a gente pode
            simplesmente usar esse nome sem ter que pensar nos detalhes de como
            ele faz o trabalho por dentro. É como uma caixa preta: você sabe o
            que entra (os argumentos) e o que sai (o resultado), mas não precisa
            se preocupar com a engrenagem interna. Essa capacidade de usar
            abstrações como caixas pretas é fundamental para gente conseguir
            construir sistemas grandes e complexos sem surtar!
          </p>
          <p>
            A abstração é a chave para gerenciar a complexidade. É como dar
            nomes para descobertas científicas complexas (“Teoria da
            Relatividade”) ou para objetos do dia a dia (“cadeira”). Em vez de
            descrever tudo cada vez, a gente usa o nome abstrato.
          </p>

          <h3 id="a-mágica-acontece">A Mágica Acontece</h3>
          <p>
            Então, a grande sacada do
            <a
              href="https://jhonatafs.github.io/sicp-pt-br/html/1_002e1.html#g_t1_002e1"
              target="_blank"
              rel="noopener noreferrer"
              >1.1</a
            >
            é essa tríade. A linguagem te dá os
            <strong>elementos simples</strong> (primitivas), te dá um jeito de
            <strong>combinar</strong> eles para fazer coisas mais complexas, e
            te dá um jeito de <strong>dar nome</strong> a essas coisas para você
            conseguir pensar e trabalhar com elas de forma mais fácil
            (abstração).
          </p>
          <p>
            É a partir dessa base que o livro (e a ciência da computação!)
            constrói tudo o mais. A magia é justamente a capacidade de ir
            empilhando complexidade e, a cada passo, criar uma nova abstração
            pra gerenciar essa complexidade.
          </p>
          <p>
            Elementos simples → Combinação → Abstração → Programas que fazem
            coisas incríveis (Mágica!).
          </p>

          <h2 id="procedimentos-e-os-processos-que-eles-geram">
            Procedimentos e os Processos que Eles Geram
          </h2>
          <p>
            Depois de entender os blocos de construção básicos – primitivas,
            como juntar tudo (combinação) e como dar nome pras coisas
            (abstração) no
            <a
              href="https://jhonatafs.github.io/sicp-pt-br/html/1_002e1.html#g_t1_002e1"
              target="_blank"
              rel="noopener noreferrer"
              >1.1</a
            >
            – o SICP joga a gente para outro nível no tópico
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e2.html%23g_t1_002e2"
              target="_blank"
              rel="noopener noreferrer"
              >1.2</a
            >. Sabe qual é? Parar de pensar só no código parado, na receita, e
            começar a
            <strong>visualizar o que acontece quando o código roda</strong>.
            Tipo, qual é a <em>dinâmica</em> que aquele procedimento cria? Que
            “processo” ele gera no computador?
          </p>
          <p>
            Essa mudança de chave é vital! Não basta só saber
            <em>escrever</em> o procedimento para calcular alguma coisa; a gente
            precisa entender <em>como</em> a máquina executa isso, passo a
            passo. É aí que começamos a ver as diferentes “formas” de processos
            computacionais.
          </p>

          <h3 id="a-forma-dos-processos-linear-e-iterativo">
            A Forma dos Processos: Linear e Iterativo
          </h3>
          <p>
            O livro explora isso a fundo com o cálculo do fatorial. A gente
            aprende a escrever a função <code>fatorial</code> de duas jeitos
            diferentes no Scheme:
          </p>
          <ol>
            <li>
              <p>
                <strong
                  >Procedimento Recursivo que Gera um Processo Recursivo
                  (Linear):</strong
                >
                Pensa na definição matemática do fatorial: n! = n * (n-1)!. Note
                que n! chama n, n vezes, isso é recursão: chamar a si mesma
                durante sua execução, dividindo um problema em subproblemas
                menores até atingir um caso base (condição de parada). Nosso
                procedimento em Scheme copia essa ideia, olhe:
              </p>
              <pre><code class="language-scheme">(define (fatorial n)
  (if (= n 1)
      1
      (* n (fatorial (- n 1)))))</code></pre>
              <p>
                Quando você roda isso, a máquina precisa ‘lembrar’ das
                multiplicações que ficaram pendentes. Ela vai empilhando as
                tarefas: <code>(* 5 (fatorial 4))</code>, depois
                <code>(* 4 (fatorial 3))</code> e assim por diante, até chegar
                no <code>(fatorial 1)</code>. Aí, ela começa a ‘desempilhar’ e
                fazer as contas. Esse é um <strong>processo recursivo</strong> –
                ele cresce e precisa de mais memória (espaço) para lembrar das
                operações pendentes, na proporção do tamanho da entrada
                (linearmente, por isso recursivo <em>linear</em>).
              </p>
            </li>
            <li>
              <p>
                <strong
                  >Procedimento Iterativo que Gera um Processo Iterativo
                  (Linear):</strong
                >
                Essa é a versão que talvez a gente não pense logo de cara, mas
                que é super eficiente. A gente usa variáveis para manter o
                estado atual da computação – tipo, qual o produto acumulado até
                agora e qual o próximo número a multiplicar. No Scheme, a gente
                faz isso de um jeito esperto, geralmente com uma função auxiliar
                que se chama recursivamente, mas de um jeito que o interpretador
                otimiza pra virar um loop (chamada de cauda recursiva). Fica
                algo assim:
              </p>
              <pre><code class="language-scheme">(define (fatorial n)
  (define (fat-iter produto contador max-contador)
    (if (> contador max-contador)
        produto
        (fat-iter (* produto contador)
                  (+ contador 1)
                  max-contador)))
  (fat-iter 1 1 n))</code></pre>
              <p>
                Aqui, a máquina não precisa ficar lembrando de operações
                futuras. Em cada passo, ela só precisa saber o produto atual e o
                contador. O estado do processo é definido por um número fixo de
                variáveis (produto e contador). Isso é um
                <strong>processo iterativo</strong>. Ele usa uma quantidade
                constante de memória (espaço), independente do tamanho da
                entrada. Pense nisso como um loop tradicional em outras
                linguagens.
              </p>
            </li>
          </ol>
          <p>
            A grande lição aqui é:
            <strong
              >a forma do <em>procedimento</em> (como você escreve o código) não
              é necessariamente a forma do <em>processo</em> (como a máquina
              executa)</strong
            >. O SICP usa o fatorial para deixar isso cristalino.
          </p>

          <h3 id="recursão-em-árvore-quando-o-processo-se-ramifica">
            Recursão em Árvore: Quando o Processo se Ramifica
          </h3>
          <p>
            Saindo do linear, a gente topa com a
            <strong>recursão em árvore</strong>. O exemplo clássico é o cálculo
            dos números de Fibonacci. Para calcular <code>fib(n)</code>, você
            precisa de <code>fib(n-1)</code> e <code>fib(n-2)</code>. Cada
            cálculo de <code>fib</code> ‘ramifica’ em dois outros, criando uma
            árvore de computações.
          </p>
          <pre><code class="language-scheme">(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))</code></pre>
          <p>
            Visualizar esse processo é ver a árvore se abrindo. É
            conceitualmente simples de escrever, seguindo a definição, mas
            computacionalmente pode ser um pesadelo, recalculando os mesmos
            valores várias e várias vezes. O problema de contar o número de
            maneiras de dar troco num valor é outro exemplo de processo que,
            escrito de forma natural, gera uma recursão em árvore.
          </p>
          <p>
            A moral da história da recursão em árvore é: cuidado com a
            ineficiência! Às vezes, a forma mais “natural” de escrever a função
            não gera o processo mais eficiente.
          </p>

          <h3 id="a-ordem-do-caos-ou-da-eficiência-ordens-de-crescimento">
            A Ordem do Caos (ou da Eficiência): Ordens de Crescimento
          </h3>
          <p>
            Para gente não ficar só na intuição sobre se um processo é eficiente
            ou não, o SICP introduz a ideia de
            <strong>ordens de crescimento</strong> (usando a notação Theta, Θ).
            É uma forma de medir, de maneira grosseira, como o
            <em>consumo de recursos</em> (tempo que leva para rodar e espaço de
            memória que usa) de um processo cresce conforme a entrada (o
            <code>n</code>) aumenta.
          </p>
          <ul>
            <li>
              Se o tempo/espaço cresce na mesma proporção que
              <code>n</code>, a gente diz que a ordem é linear, Θ(n).
            </li>
            <li>
              Se cresce na proporção do quadrado de <code>n</code>,
              Θ(n<sup>2</sup>).
            </li>
            <li>
              Se cresce na proporção do logaritmo de <code>n</code>, Θ(log n).
            </li>
            <li>
              Se cresce muito rápido, tipo exponencialmente (como o
              <code>fib</code> recursivo que gera um processo em árvore
              ingênuo), Θ(2<sup>n</sup>).
            </li>
            <li>
              Se cresce extremamente rapido sendo até incomputavel, Θ(A<sup
                >n<sup>n<sup>…</sup></sup></sup
              >) ou Θ(A(n, n))
            </li>
          </ul>
          <p>
            Entender as ordens de crescimento é fundamental para gente ter uma
            noção de performance sem precisar medir o tempo exato em
            milissegundos. É sobre a <em>taxa</em> de crescimento.
          </p>
          <p>
            Note que o tópico
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e2.html%23g_t1_002e2"
              target="_blank"
              rel="noopener noreferrer"
              >1.2</a
            >
            te força a olhar para dentro da caixa preta. Não é mais só sobre a
            receita (o procedimento), mas sobre o cozimento (o processo). A
            gente aprende que a mesma receita pode ser cozinhada de formas
            diferentes, gerando processos com dinâmicas (e eficiências!) bem
            distintas. A distinção entre procedimento recursivo/iterativo (como
            você escreve) e processo recursivo/iterativo (como a máquina
            executa) é um dos grandes “aha!” moments dessa seção. E começar a
            pensar em ordens de crescimento te dá uma ferramenta poderosa para
            comparar a ‘potência’ ou o ‘custo’ dos seus processos. É a
            matemática voltando para te dar superpoderes analíticos!
          </p>

          <h2 id="formulando-abstrações-com-procedimentos-de-ordem-superior">
            Formulando Abstrações com Procedimentos de Ordem Superior
          </h2>
          <p>
            Se o
            <a
              href="https://jhonatafs.github.io/sicp-pt-br/html/1_002e1.html#g_t1_002e1"
              target="_blank"
              rel="noopener noreferrer"
              >1.1</a
            >
            te deu os blocos e o
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e2.html%23g_t1_002e2"
              target="_blank"
              rel="noopener noreferrer"
              >1.2</a
            >
            te fez sacar a dinâmica dos processos, o tópico
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e3.html%23g_t1_002e3"
              target="_blank"
              rel="noopener noreferrer"
              >1.3</a
            >
            é onde o negócio fica <em>realmente</em> poderoso e a gente começa a
            ver o que significa “construir abstrações com procedimentos” de uma
            forma mais sofisticada.
          </p>
          <p>
            Aqui a gente mergulha na ideia de tratar
            <strong>procedimentos como “cidadãos de primeira classe”</strong>. O
            que isso significa? Basicamente, que na linguagem Scheme, os
            procedimentos podem ser manipulados como qualquer outro “dado” –
            tipo números ou textos. Você pode:
          </p>
          <ul>
            <li>
              Passar um procedimento como <strong>argumento</strong> para outro
              procedimento.
            </li>
            <li>
              Retornar um procedimento como o
              <strong>resultado</strong> de outro procedimento (embora o livro
              explore mais isso depois, a semente é plantada aqui).
            </li>
            <li>
              Vincular um procedimento a um <strong>nome</strong> (o que a gente
              já viu com o <code>define</code>, mas agora a gente vê o poder
              disso combinado com o resto).
            </li>
          </ul>
          <p>
            Essa capacidade de tratar procedimentos como dados é o que permite
            criar
            <strong>procedimentos de ordem superior</strong> (Higher-Order
            Procedures - HOPs). São procedimentos que
            <em>operam em outros procedimentos</em>, seja recebendo um
            procedimento como entrada ou gerando um procedimento como saída.
            Parece papo de maluco no início, mas é aí que a mágica da abstração
            atinge um novo patamar.
          </p>

          <h3 id="procedimentos-como-argumentos-a-fábrica-de-ideias-comuns">
            Procedimentos como Argumentos: A Fábrica de Ideias Comuns
          </h3>
          <p>
            O livro mostra isso com um exemplo clássico: somar séries. Tipo,
            somar os números de 1 a 10, somar os quadrados de 1 a 10, somar os
            inversos de 1 a 10… Percebe um padrão? Você tá sempre somando uma
            <strong>sequência de termos</strong>, onde cada termo é calculado
            usando uma <strong>regra</strong> diferente (o número em si, o
            quadrado dele, o inverso dele).
          </p>
          <p>
            Em vez de escrever uma função <code>soma-inteiros</code>, outra
            <code>soma-quadrados</code>, outra <code>soma-inversos</code>, a
            gente pode criar um procedimento <strong>geral</strong> de soma!
          </p>
          <pre><code class="language-scheme">(define (soma termo a proximo b)
  (if (> a b)
      0
      (+ (termo a)
         (soma termo (proximo a) proximo b))))</code></pre>
          <p>Agora, a “mastigação” dos pontos:</p>
          <ul>
            <li>
              <p>
                <strong><code>termo</code></strong>
              </p>
              <p>
                Imagina que o <code>soma</code> é um cara que sabe andar por uma
                lista de números (<code>a</code> até <code>b</code>) e somar
                coisas. Mas ele é meio lerdo e não sabe
                <em>o que exatamente</em> ele tem que somar em cada posição.
                Você tem que dar essa instrução para ele!
              </p>
              <p>
                O argumento <code>termo</code> é exatamente isso: é o
                <strong>procedimento</strong> que o <code>soma</code> vai chamar
                para descobrir o <strong>valor</strong> que ele tem que somar
                <strong>agora</strong>, na posição atual <code>a</code>**.
              </p>
              <ul>
                <li>
                  Quer somar os <em>números</em> de 1 a 10? O “termo” que você
                  soma na posição 5 é o próprio 5. Então, você passa um
                  procedimento que simplesmente retorna o número que recebeu.
                  Chamamos esse procedimento de <code>identidade</code>:
                  <code>(define (identidade x) x)</code>. Você passaria
                  <code>identidade</code> como o argumento <code>termo</code>.
                </li>
                <li>
                  Quer somar os <em>quadrados</em> de 1 a 10? O “termo” que você
                  soma na posição 5 é o quadrado de 5, que é 25. Então, você
                  passa o procedimento <code>quadrado</code> que a gente viu
                  antes: <code>(define (quadrado x) (* x x))</code>. Você
                  passaria <code>quadrado</code> como o argumento
                  <code>termo</code>.
                </li>
                <li>
                  Quer somar os <em>inversos</em> de 1 a 10? O “termo” que você
                  soma na posição 5 é 1/5. Você passaria um procedimento que
                  calcula o inverso: <code>(define (inverso x) (/ 1 x))</code>.
                </li>
              </ul>
              <p>
                Sacou? O <code>termo</code> não é um número, não é um nome
                qualquer. É uma <strong>funçãozinha</strong>, um
                <strong>procedimento</strong>, que o <code>soma</code> chama em
                cada passo para saber “qual o valor que eu pego dessa posição
                aqui para somar?”. Você tá dando para ele a <em>regra</em> de
                como transformar a posição atual no valor a ser somado.
              </p>
            </li>
            <li>
              <p>
                <strong><code>proximo</code></strong>
              </p>
              <p>
                Beleza, o <code>soma</code> sabe qual valor pegar na posição
                <code>a</code> (usando o procedimento <code>termo</code>). Mas e
                depois? Como ele anda para próxima posição?
              </p>
              <p>
                O argumento <code>proximo</code> diz isso a ele: é o
                <strong>procedimento</strong> que o <code>soma</code> vai chamar
                para descobrir qual é a <strong>próxima</strong> posição na
                sequência, depois da posição atual <code>a</code>.
              </p>
              <ul>
                <li>
                  Quer somar uma sequência normal, tipo 1, 2, 3, 4…? A próxima
                  posição depois de 5 é 6. Você precisa de um procedimento que
                  some 1 ao número que recebe. Chamamos esse de
                  <code>incremento</code>:
                  <code>(define (incremento x) (+ x 1))</code>. Você passaria
                  <code>incremento</code> como o argumento <code>proximo</code>.
                </li>
                <li>
                  E se você quisesse somar só os números
                  <em>ímpares</em> numa faixa? Tipo, 1, 3, 5, 7…? A próxima
                  posição depois de 5 é 7. Você precisaria de um procedimento
                  que somasse 2 ao número que recebe. Você passaria um
                  procedimento tipo <code>(lambda (x) (+ x 2))</code> como o
                  argumento <code>proximo</code>.
                </li>
              </ul>
              <p>
                De novo, o <code>proximo</code> não é um número fixo, é uma
                <strong>funçãozinha</strong>, um <strong>procedimento</strong>,
                que o <code>soma</code> chama em cada passo para saber “qual a
                próxima posição que eu tenho que ir depois dessa?”. Você tá
                dando para ele a <em>regra</em> de como avançar na sua “lista”
                ou “sequência” de números.
              </p>
            </li>
          </ul>
          <p><strong>Por que isso é genial?</strong></p>
          <p>
            Porque o procedimento <code>soma</code> em si é totalmente
            <strong>genérico</strong>. Ele não sabe se tá somando inteiros,
            quadrados ou inversos. Ele só sabe seguir as instruções que você dá
            para ele através dos procedimentos <code>termo</code> e
            <code>proximo</code>. Você “programa” o comportamento específico da
            soma (o que somar e como avançar) passando
            <em>outros procedimentos</em> como dados para ele.
          </p>
          <p>
            É como ter um robô que sabe somar, mas você troca os “olhos” (o
            procedimento <code>termo</code> que diz o que ele vê/pega para
            somar) e as “pernas” (o procedimento <code>proximo</code> que diz
            como ele anda para a próxima posição). O robô (<code>soma</code>) é
            o mesmo, mas o que ele faz muda completamente dependendo dos
            “acessórios” (os procedimentos) que você dá a ele.
          </p>
          <p>
            Essa é a beleza e o poder dos procedimentos de ordem superior: eles
            nos permitem encapsular métodos gerais, e as especificidades desse
            método são fornecidas por outros procedimentos que são passados como
            se fossem dados normais.
          </p>

          <h3 id="lambda-procedimentos-anônimos-na-hora-h">
            Lambda: Procedimentos Anônimos na Hora H
          </h3>
          <p>
            Às vezes, você precisa passar um procedimento como argumento, mas
            ele é tão simples ou tão específico praquele lugar que dar um nome
            <code>define</code> para ele parece exagero. Para isso, o SICP te
            apresenta o <code>lambda</code>.
          </p>
          <p>
            <code>lambda</code> te permite criar um procedimento “na hora”, sem
            dar um nome a ele. É como criar uma função anônima.
          </p>
          <pre><code class="language-scheme">(lambda (x) (* x x))
; Um procedimento que recebe x e retorna x*x (o quadrado)</code></pre>
          <p>
            Isso sozinho não faz nada, mas você pode usar ele diretamente onde
            um procedimento é esperado, como argumento de um HOP:
          </p>
          <pre><code class="language-scheme">(soma (lambda (x) (* x x))
      1
      (lambda (x) (+ x 1))
      10)</code></pre>
          <p>
            Isso faz a mesma coisa que
            <code>(soma quadrado 1 incremento 10)</code>, mas sem precisar
            definir <code>quadrado</code> e
            <code>incremento</code> separadamente se você só for usá-los ali. O
            <code>lambda</code> dá uma fluidez incrível pra usar HOPs.
          </p>
          <p>
            E é nesse ponto que o livro também mostra o <code>let</code>. O
            <code>let</code> não cria procedimentos novos diretamente como o
            <code>lambda</code>, mas ele é uma ferramenta útil para criar
            variáveis temporárias, com um escopo bem restrito, só para usar ali,
            naquele pedaço de código.
          </p>
          <p>
            Pensa assim: às vezes, dentro de um cálculo, você precisa calcular
            um valor intermediário e dar um nome para ele rapidinho só para
            organizar a conta, mas não quer que esse nome “vaze” e atrapalhe o
            resto do seu programa. O
            <code>let</code> faz exatamente isso!
          </p>
          <pre><code class="language-scheme">(let ((local-variavel valor) ... )
; Tudo o que tiver aqui: ... usará
; a variavel: local-variavel</code></pre>
          <p>
            <strong>E a conexão com o <code>lambda</code>?</strong> O SICP
            revela que o <code>let</code> é, na verdade, um “açúcar sintático”
            para uma combinação esperta usando <code>lambda</code>! Quando você
            escreve um <code>let</code>, o interpretador do Scheme, por baixo
            dos panos, traduz aquilo para algo que usa um
            <code>lambda</code> para criar aquele escopo local e vincular a
            variável.
          </p>
          <p>
            Tipo, um <code>(let ((x 10)) (+ x 5))</code> é basicamente
            transformado em <code>((lambda (x) (+ x 5)) 10)</code>. A gente não
            precisa se preocupar com essa tradução na hora de usar o
            <code>let</code>, mas saber que ele se baseia no
            <code>lambda</code> mostra como esses mecanismos de abstração e
            combinação estão interligados na linguagem.
          </p>
          <p>
            Então, enquanto o <code>lambda</code> te dá a flexibilidade de criar
            procedimentos anônimos, o <code>let</code> te dá a conveniência de
            criar nomes temporários (variáveis locais) para organizar seu
            código, e os dois trabalham juntos, com o <code>let</code> sendo
            construído em cima do poder do <code>lambda</code>.
          </p>

          <h3
            id="procedimentos-como-métodos-gerais-a-essência-da-ciência-da-computação"
          >
            Procedimentos como Métodos Gerais: A Essência da Ciência da
            Computação
          </h3>
          <p>
            A cereja do bolo do
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e3.html%23g_t1_002e3"
              target="_blank"
              rel="noopener noreferrer"
              >1.3</a
            >
            é ver como essas ideias – procedimentos como cidadãos de primeira
            classe, HOPs, <code>lambda</code> – nos permitem expressar
            <strong>métodos computacionais gerais</strong>. Não é mais sobre
            resolver <em>um</em> problema específico (tipo calcular uma raiz de
            9); é sobre implementar o <em>método</em> de encontrar raízes que
            funcione para <em>qualquer</em> função.
          </p>
          <p>O livro demonstra isso com exemplos como:</p>
          <ul>
            <li>
              <strong>O Método da Bissecção:</strong> Um jeito geral de
              encontrar raízes de equações. Você pode escrever um procedimento
              de ordem superior que recebe a função que você quer encontrar a
              raiz, um intervalo onde procurar, e ele aplica o método da
              bissecção.
            </li>
            <li>
              <strong>Busca por Ponto Fixo:</strong> Um método geral para
              encontrar um valor <code>x</code> onde <code>f(x) = x</code>. De
              novo, você escreve um HOP que recebe a função <code>f</code> e
              aplica a busca por ponto fixo.
            </li>
          </ul>
          <p>
            Nesses casos, o procedimento de ordem superior encapsula a
            <strong>lógica do método</strong>. A função específica (<code
              >f(x) = x² - 9</code
            >
            para encontrar a raiz de 9, ou <code>f(x) = cos(x)</code> para um
            ponto fixo do cosseno) é passada como um argumento!
          </p>

          <h3 id="a-abstração-de-poder-máximo">A Abstração de Poder Máximo</h3>
          <p>
            O tópico
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e3.html%23g_t1_002e3"
              target="_blank"
              rel="noopener noreferrer"
              >1.3</a
            >
            te eleva. Você para de pensar só nas operações concretas e começa a
            pensar em <strong>padrões computacionais</strong> e
            <strong>métodos gerais</strong>. Procedimentos deixam de ser apenas
            sequências de instruções para se tornarem entidades que podem ser
            manipuladas, combinadas e usadas para construir abstrações ainda
            mais poderosas. A capacidade de tratar procedimentos como dados é o
            que desbloqueia essa nova camada de expressividade e permite que a
            gente escreva código que não só resolve problemas, mas que também
            <em>estrutura</em> nossas ideias sobre como resolver
            <em>classes inteiras</em> de problemas.
          </p>
          <p>
            É aqui que a frase “Uma linguagem de programação poderosa serve…
            como estrutura para a organização de ideias sobre processos” do
            início do capítulo ecoa mais forte. No
            <a
              href="https://www.google.com/search?q=https://jhonatafs.github.io/sicp-pt-br/html/1_002e3.html%23g_t1_002e3"
              target="_blank"
              rel="noopener noreferrer"
              >1.3</a
            >, os procedimentos de ordem superior se tornam nossas principais
            ferramentas para organizar e expressar essas ideias de forma
            elegante e poderosa.
          </p>
        </article>
        <a href="/" class="back-link bottom-link"
          >&larr; Voltar para a página inicial</a
        >
      </div>
    </main>

    <footer class="site-footer">
      <div class="container">
        <p>
          &copy; <span id="current-year"></span> Jhonata Flores. Compartilhando
          a jornada do aprendizado.
        </p>
      </div>
    </footer>

    <script src="/js/script.js"></script>
  </body>
</html>
