<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="application-name" content="Notas: MIT 6.001" />
    <meta name="description" content="Blog" />
    <link rel="icon" type="image/png" href="/img/fovicon.svg" />
    <title>JhonFs: Notas MIT 6.001 Cap. 1.2</title>
    <!--CSS-->
    <link rel="stylesheet" href="/css/normilize.css" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/icons.css" />
    <link rel="stylesheet" href="/css/highlight.css" />
    <link rel="stylesheet" href="/css/article.css" />
    <!--SCRIPT-->
    <script src="/js/light.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/markdown.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <main>
      <div id="top"></div>
      <button id="backToTop"><span class="icon_angles_up"></span></button>
      <script src="/js/buttonToTop.js"></script>

      <nav role="navigation">
        <!--Based on the code of Erik Terwan (24th of November 2015, MIT License)-->
        <div id="menuToggle">
          <input type="checkbox" id="menuCheckbox" />

          <!--Icon Hamburguer-->
          <span></span>
          <span></span>
          <span></span>

          <ul id="menu">
            <div class="nav-page">
              <li>
                <a href="1.1 Os Elementos da Programação.html"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_page_previous"
                  ></label
                ></a>
              </li>
              <li>
                <a href="/index.html"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_home"
                  ></label
                ></a>
              </li>
              <li>
                <a href="Guia.html#guia"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_content"
                  ></label
                ></a>
              </li>
              <li>
                <a
                  href="1.3 Formulando Abstrações com Procedimentos de Ordem Superior.html"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_page_next"
                  ></label
                ></a>
              </li>
            </div>
            <hr />
            <li>
              <a href="#1.2"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2 Procedimentos e os Processos que Eles Geram</label
                ></a
              >
            </li>
            <li>
              <a href="#1.2.1"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.1 Recursão Linear e Iteração</label
                ></a
              >
            </li>
            <ul class="exercises">
              <li>
                <a href="#e_1.9"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.9</label
                  ></a
                >
              </li>
              <li>
                <a href="#e_1.10"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.10</label
                  ></a
                >
              </li>
            </ul>
            <li>
              <a href="#1.2.2"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.2 Recursão em Árvore</label
                ></a
              >
            </li>
            <ul class="exercises">
              <li>
                <a href="#e_1.11"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.11</label
                  ></a
                >
              </li>
              <li>
                <a href="#e_1.12"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.12</label
                  ></a
                >
              </li>
              <li>
                <a href="#e_1.13"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.13</label
                  ></a
                >
              </li>
            </ul>
            <li>
              <a href="#1.2.3"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.3 Ordens de Crescimento</label
                ></a
              >
              <ul class="exercises">
                <li>
                  <a href="#e_1.14"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.14</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.15"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.15</label
                    ></a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#1.2.4"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.4 Exponenciação
                </label></a
              >
              <ul class="exercises">
                <li>
                  <a href="#e_1.16"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.16</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.17"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.17</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.18"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.18</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.19"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.19</label
                    ></a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#1.2.5"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.5 Máximo Divisor Comum</label
                ></a
              >
              <ul class="exercises">
                <li>
                  <a href="#e_1.20"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.20</label
                    ></a
                  >
                </li>
              </ul>
            </li>
            <li>
              <a href="#1.2.6"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.6 Exemplo: Testando Primalidade</label
                ></a
              >
              <ul class="exercises">
                <li>
                  <a href="#e_1.21"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.21</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.22"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.22</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.23"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.23</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.24"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.24</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.25"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.25</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.26"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.26</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.27"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.27</label
                    ></a
                  >
                </li>
                <li>
                  <a href="#e_1.28"
                    ><label for="menuCheckbox" onclick="this.parentNode.click();">
                      Quest. 1.28</label
                    ></a
                  >
                </li>
              </ul>
            </li>
            <hr />
            <div class="buttons">
              <a
                href="https://github.com/Jhonatafs"
                class="icon_github"
                target="_blank"
              ></a>
              <a
                href="https://www.linkedin.com/in/jhonfs/"
                class="icon_linkedin"
                target="_blank"
              ></a>
              <a href="#" class="icon_translate disabled"></a>
              <button id="button-light" onclick="lightStatus()">
                <span class="icon_theme"></span>
              </button>
            </div>
          </ul>
        </div>
      </nav>
      <article>
        <h1 id="1.2">1.2 Procedimentos e os Processos que Eles Geram</h1>
        <p>
          O que é um bom programador? Um bom programador é definido por
          habilidades que vão além do conhecimento técnico básico (como
          operações e sintaxe). Os elementos essenciais são:
        </p>
        <ol>
          <li>Capacidade de Visualizar Processos</li>
          <ul>
            <li>
              <strong>Antecipar consequências:</strong> Saber prever como um
              procedimento ou linha de código afetará o fluxo do programa, a
              eficiência, a manutenção e o resultado.
            </li>
            <li>
              <strong>Simulação mental:</strong> Entender como o processo gerado
              por um código se desenrola, passo a passo, incluindo estados
              intermediários e possíveis erros.
            </li>
          </ul>
          <li>Experiência com Padrões e Estratégias</li>
          <ul>
            <li>
              <strong>Conhecimento de "movimentos valiosos":</strong> Dominar
              padrões de projeto, algoritmos eficientes e boas práticas.
            </li>
            <li>
              <strong>Abstração eficaz:</strong> Saber combinar operações
              primitivas em procedimentos úteis e reutilizáveis.
            </li>
          </ul>
          <li>Planejamento Sintético e Raciocínio Lógico</li>
          <ul>
            <li>
              <strong>Pensamento reverso:</strong> Trabalhar de trás para frente
              a partir do resultado desejado (como um fotógrafo planeja
              exposição).
            </li>
            <li>
              <strong>Controle do processo:</strong> Garantir execução ordenada
              e confiável do programa.
            </li>
          </ul>
          <li>Aprendizado Contínuo com a Prática</li>
          <ul>
            <li>
              <strong>Experiência acumulada:</strong> Desenvolver intuição
              através da exposição a cenários complexos.
            </li>
            <li>
              <strong>Adaptação:</strong> Ajustar estratégias conforme o
              contexto (como técnicas fotográficas).
            </li>
          </ul>
        </ol>

        <h2 id="1.2.1">1.2.1 Recursão Linear e Iteração</h2>
        <ol>
          <li><mark>Processo</mark> Recursivo Linear:</li>
          <ul>
            <li>
              Expansão (acúmulo de operações) seguida de contração (execução das
              operações).
            </li>
            <li>
              Requer memória proporcional a <em>n</em> (crescimento linear),
              pois o interpretador rastreia a cadeia de operações pendentes.
            </li>
          </ul>
          <li><mark>Processo</mark> Iterativo Linear:</li>
          <ul>
            <li>Usa variáveis de estado atualizadas iterativamente:</li>
            <li>
              Mantém estado fixo, evoluindo em espaço constante (memória fixa),
              mesmo para grandes <em>n</em>.
            </li>
          </ul>
        </ol>
        <p>
          Sintaxe recursiva (porém com chamadas de cauda) gera processo
          iterativo. Mantendo um espaço constante, pois o estado é totalmente
          descrito pelas variáveis a cada passo. Exemplos em outras linguagens:
          o <code>for</code> e o <code>while</code>. A recursão sintática
          (código que chama a si) não implica necessariamente um processo
          recursivo (com crescimento de memória). Um procedimento recursivo pode
          gerar um processo iterativo se for tail-recursive<sup id="sup4"
            ><a href="#ref4">4</a></sup
          >
          (recursão de cauda).
        </p>
        <hr />
        <h4 id="e_1.9">Exercício 1.9: Resposta</h4>
        <p>Processo Recursivo:</p>
        <pre><code class="language-scheme">
(+ 4 5)                         ;; Chamada do procedimento 1
(inc (+ 3 5))                   ;; Passo 1: inc é adiado
(inc (inc (+ 2 5)))             ;; Passo 2: incs acumulam
(inc (inc (inc (+ 1 5))))       ;; Passo 3
(inc (inc (inc (inc (+ 0 5))))) ;; Passo 4: caso-base (a=0)
(inc (inc (inc (inc 5))))       ;; Passo 5: contração começa
(inc (inc (inc 6)))             ;; Passo 6
(inc (inc 7))                   ;; Passo 7
(inc 8)                         ;; Passo 8
9                               ;; Resultado
        </code></pre>
        <p>Processo Interativo:</p>
        <pre><code class="language-scheme">
(+ 4 5) ;; Chamada do procedimento 2
(+ 3 6) ;; Passo 1: atualizar a e b
(+ 2 7) ;; Passo 2
(+ 1 8) ;; Passo 3
(+ 0 9) ;; Passo 4: caso-base (a=0)
9       ;; Resultado
        </code></pre>
        <h4 id="e_1.10">Exercício 1.10: Resposta</h4>
        <p>Os valores das expressões são:</p>
        <pre><code class="language-scheme">
(A 1 10)
1024 ;; Resposta

(A 2 4)
65536 ;; Resposta

(A 3 3)
65536 ;; Resposta
        </code></pre>
        <p>
          Definições matemáticas para <code>(f n)</code>, <code>(g n)</code>,
          <code>(h n)</code>, <code>(k n)</code>
        </p>
        <pre><code class="language-scheme">
(f n) ;; Sendo n > 0
;; f(n) = 2n

(g n) ;; Sendo n > 0
;; g(n) = 2^n

(h n) ;; Sendo n > 0
;; h(n) = 2↑↑n = 2^(h(n-1)) = 2^(2^(h(n-1))) = 2^(2^(2^(...^(2))))
;; Exemplo:
;;;; h(1) = 2
;;;; h(2) = 2^2 = 4
;;;; h(3) = 2^(2^2) = 16
;;;; h(4) = 2^(2^(2^2)) = 65536

;; (k n) => 5n^2
        </code></pre>
        <h2 id="1.2.2">1.2.2 Recursão em Árvore</h2>
        <ul>
          <li>
            Padrão de função recursiva que gera estruturas semelhantes a
            árvores.
          </li>
          <li>
            Cada chamada recursiva cria "ramos" que se dividem até atingir um
            caso-base.
          </li>
          <li>
            O número de passos cresce rapidamente, proporcional ao número de nós
            na árvore. O crescimento temporal é exponencial.
          </li>
          <li>
            O espaço necessário cresce proporcional à profundidade da árvore.
            Apenas os nós ativos na recursão são armazenados na memória. O
            crescimento espacial é linear.
          </li>
          <li>
            É natural para problemas com estruturas hierárquicas (ex: árvores de
            dados). Mas é ineficiente para entradas grandes devido a cálculos
            redundantes e aí entra a função interativa.
          </li>
        </ul>
        <h4 id="e_1.11">Exercício 1.11: Resposta</h4>
        <p>Regra:</p>
        <math display="block">
          <mrow>
            <mi>f</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
            <mo>=</mo>
            <mrow>
              <mo>{</mo>
              <mtable columnalign="left left" rowspacing="0.2em">
                <mtr>
                  <mtd>
                    <mi>n</mi>
                  </mtd>
                  <mtd>
                    <mtext>para</mtext>
                    <mi>n</mi>
                    <mo><</mo>
                    <mn>3</mn>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd>
                    <mi>f</mi>
                    <mo>(</mo>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                    <mo>+</mo>
                    <mn>2</mn>
                    <mi>f</mi>
                    <mo>(</mo>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>2</mn>
                    <mo>)</mo>
                    <mo>+</mo>
                    <mn>3</mn>
                    <mi>f</mi>
                    <mo>(</mo>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>3</mn>
                    <mo>)</mo>
                  </mtd>
                  <mtd>
                    <mtext>para</mtext>
                    <mi>n</mi>
                    <mo>≥</mo>
                    <mn>3</mn>
                  </mtd>
                </mtr>
              </mtable>
              <mo>}</mo>
            </mrow>
          </mrow>
        </math>
        <br />
        <p>Para <em>f(n)</em> como procedimento recursivo:</p>
        <pre><code class="language-scheme">
(define (f n)
  (if (n &lt; 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3)))
      )
  )
)
        </code></pre>
        <br />
        <br />
        <p>Para <em>f(n)</em> como procedimento interativo:</p>
        <ol>
          <li>Se n &lt; 3 é retornado n</li>
          <pre><code class="language-scheme">
(if (n &lt; 3) n ...)
          </code></pre>
          <li>Preciso armazenar os valores:</li>
          <ul>
            <li><code>f(n-1) = a</code></li>
            <li><code>f(n-3) = b</code></li>
            <li><code>f(n-2) = c</code></li>
          </ul>
          <li>O valor base é quando <code>n = 3</code>, então:</li>
          <ul>
            <li>Valor inicial: <code>a = 2</code></li>
            <li>Valor inicial: <code>b = 1</code></li>
            <li>Valor inicial: <code>c = 0</code></li>
          </ul>
          <li>
            Quando <code>n &gt; 3</code> é preciso calcular várias vezes
            <em>f(n)</em>, para isso preciso atualiza os valores durante o
            processo a fim de não criar um processo recursivo, onde:
            <ul>
              <li><code>c = b</code></li>
              <li><code>b = a</code></li>
              <li><code>a = f(n-1) + 2f(n-2) + 3f(n-3)</code></li>
            </ul>
            Logo preciso de um loop e uma variável de controle que pare o loop
            quando igual ao valor de <code>n</code>, já que o cálculo será feito
            a partir do valor de base e o cálculo repetirá n vezes:
          </li>
        </ol>

        <pre><code class="language-scheme">
(define (loop controle a b c)
  (if (= n controle)
      controle
      (loop (+ 1 controle)
            (+ a (* 2 b) (* 3 c))
            a                  
            b
            
      )
  )
)
        </code></pre>
        <br />
        <br />
        <p>O Procedimento completo fica:</p>
        <pre><code class="language-scheme">
(define (i n)
  (define (loop controle a b c)
    (if (= n controle)
        a                           ;; Aqui retorna o valor do cálculo
        (loop                       ;; Chamada para atualizar os valores
              (+ 1 controle)        ;; Mecanismo de stop
              (+ a (* 2 b) (* 3 c)) ;; Novo 'a'
              a                     ;; Novo 'b'                  
              b                     ;; Novo 'c'
        )
    )
  )

  (if (&lt; n 3)
      3
                                    ;; Aqui determino o valor inicial de 'a',
                                    ;; 'b', 'c' e da variável de controle:
                                    ;; (loop &lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;controle&gt;)  
      (loop 2 2 1 0)   
  )
)
        </code></pre>
        <h4 id="e_1.12">Exercício 1.12: Resposta</h4>
        <ul>
          <li>O triangulo é formado por linhas (l)</li>
          <li>
            O número da linha determina quantos números haverá nela, exemplo:
          </li>
          <ul>
            <li>Linha 1 = 1 número</li>
            <li>Linha 2 = 2 números</li>
            <li>Linha 3 = 3 números</li>
            <li>...</li>
          </ul>
          <li>
            A primeira posição <code>p</code> na linha pode ser zero ou 1, vou
            usar 1 como posição inicial, pois se eu usar 0 o número de elementos
            em cada linha será <code>l + 1</code> e não <code>l</code>. O Que
            evita eu ter que implementar algo para deixar natural para o usuário
            final.
          </li>
          <li>
            As outras posição é definida pela soma de 2 números da linha de
            anterior, sendo:
            <ul>
              <li>
                O primeiro número da mesma posição:
                <pre><code class="language-scheme">
(+ (- l 1)  ;; Linha Anterior
   (p))     ;; Posição do número atual
                </code></pre>
              </li>
              <li>
                O segundo número da posição anterior
                <pre><code class="language-scheme">
(+ (- l 1)  ;; Linha Anterior
   (+ p 1)) ;; Posição do número atual
                </code></pre>
              </li>
            </ul>
          </li>
          <li>Então a função fica:</li>
          <pre><code class="language-scheme">
(define (pascal l p)
  (cond 
    ;; Verifica se a posição é inválida
    ((or (&lt; p 1) (> p l)) 0) ;; Retorna 0 para posições inválidas

    ;; Converte linhas negativas para positivas
    ((&lt;= l 0) (pascal (abs l) p)) ;; Evita linhas *negativas

    ;; Casos-base: bordas da linha
    ((= p 1) 1) ;; Primeira posição da linha → 1
    ((= p l) 1) ;; Última posição da linha → 1

    ;; Passo recursivo: soma dos dois elementos acima
    (else 
      (+ (pascal (- l 1) p)        ;; Elemento acima (n-1, p)
          (pascal (- l 1) (- p 1))  ;; Elemento acima à esquerda (n-1, p-1)
      )
    ) 
  )      
)      
          </code></pre>
        </ul>

        <h4 id="e_1.13">Exercício 1.13: Resposta</h4>
        <p>...</p>

        <!--
          <h2 id="1.2.4">1.2.4 Exponenciação</h2>
          <h2 id="1.2.5">1.2.5 Máximo Divisor Comum</h2>
          <h2 id="1.2.6">1.2.6 Exemplo: Teste de Primalidade</h2>
          -->
        <h2 id="1.2.3">1.2.3 Ordens de Crescimento</h2>
        <p>
          Ordens de Crescimento são uma maneira de descrever como o consumo de
          recursos (como tempo ou espaço) de um processo computacional aumenta à
          medida que o tamanho do problema cresce. Imagine que você tem um
          algoritmo que leva R(n) passos para ser executado, onde <em>n</em> é o
          tamanho da entrada. Se <em>R(n) = Θ(n²)</em>, isso significa que, para
          entradas grandes, o tempo de execução do seu algoritmo crescerá
          aproximadamente como o quadrado do tamanho da entrada:
        </p>

        <ol>
          <li>
            <strong>Processo Linear</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(n)</em> passos, o número de
                operações cresce linearmente com <em>n</em>.
              </li>
              <li>
                <strong>Exemplo</strong>: Se você dobrar o tamanho do problema
                <em>n</em>, o número de operações também dobrará.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Quadrático</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(n<sup>2</sup>)</em> passos, o número
                de operações cresce quadraticamente com <em>n</em>.
              </li>
              <li>
                <strong>Exemplo</strong>: Dobrar o tamanho do problema
                quadruplicará o número de operações.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Exponencial</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(ϕ<sup>n</sup>)</em> passos (onde
                <em>ϕ</em> é a razão áurea), o número de operações cresce
                exponencialmente com <em>n</em>.
              </li>
              <li>
                <strong>Exemplo</strong>: Cada incremento no tamanho do problema
                multiplicará o número de operações por um fator constante.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Logarítmico</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(log n)</em>passos, o número de
                operações cresce lentamente, mesmo quando <em>n</em> aumenta
                significativamente.
              </li>
              <li>
                <strong>Exemplo</strong>: Dobrar o tamanho do problema aumenta o
                número de operações por uma quantidade constante.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Não Primitivo-Recursivo</strong>:
            <ul>
              <li>
                Se um processo requer uma função
                <strong>não primitiva-recursiva</strong>, como a Função de
                Ackermann <em>A(n, n)</em>, o número de operações cresce de
                forma extremamente rápida, ultrapassando qualquer função
                primitiva-recursiva.
              </li>
              <li>
                <strong>Exemplo</strong>: A Função de Ackermann
                <em>A(4, n) </em> já produz números tão grandes que são
                praticamente incomputáveis para valores modestos de <em>n</em>.
              </li>
              <li>
                <strong>Característica</strong>: O crescimento é tão acelerado
                que não pode ser descrito por funções como exponenciais,
                fatoriais ou torres de potências.
              </li>
            </ul>
          </li>
        </ol>

        <table>
          <thead>
            <tr>
              <th>Tipo de Processo</th>
              <th>Ordem de Crescimento</th>
              <th>Exemplo de Comportamento</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Logarítmico</strong></td>
              <td><em>Θ(log n)</em></td>
              <td>Crescimento muito lento.</td>
            </tr>
            <tr>
              <td><strong>Linear</strong></td>
              <td><em>Θ(n)</em></td>
              <td>Crescimento proporcional ao tamanho do problema.</td>
            </tr>
            <tr>
              <td><strong>Quadrático</strong></td>
              <td><em>Θ(n<sup>2</sup>)</em></td>
              <td>Crescimento rápido, mas gerenciável.</td>
            </tr>
            <tr>
              <td><strong>Exponencial</strong></td>
              <td><em>Θ(ϕ<sup>n</sup>)</em></td>
              <td>Crescimento explosivo, impraticável para n grande.</td>
            </tr>
            <tr>
              <td><strong>Não Primitivo-Recursivo</strong></td>
              <td><em>Θ(A(n, n))</em></td>
              <td>Crescimento extremamente rápido, incomputável.</td>
            </tr>
          </tbody>
        </table>
        <h4 id="e_1.14">Exercício 1.14: Resposta</h4>
        <p>Árvore ilustrativa do processo <code>count-change</code>:</p>
        <figure>
          <figcaption>
            Figura retirada de
            <a
              href="https://sicp-solutions.net/post/sicp-solution-exercise-1-14/"
              target="_blank"
              >Sicp-Solutions</a
            >
          </figcaption>
          <img src="img/fig-e_1.14.svg" alt="" />
        </figure>
        <p>A Imagem representa:</p>
        <pre><code class="language-scheme">
(count-change 11) ;; Chamada Inicial
;; (cc 11 5) → (+ (cc 11 4) (cc -39 5))
;; (cc 11 4) → (+ (cc 11 3) (cc -14 4))
;; (cc 11 3) → (+ (cc 11 2) (cc   1 3))
;; (cc 11 2) → (+ (cc 11 1) (cc   6 2))
;; (cc 11 1) → (+ (cc 11 0) (cc  10 1))
;; (cc 10 1) → (+ (cc 10 0) (cc   9 1))
;; (cc  9 1) → (+ (cc  9 0) (cc   8 1))
;; (cc  8 1) → (+ (cc  8 0) (cc   7 1))
;; (cc  7 1) → (+ (cc  7 0) (cc   6 1))
;; (cc  6 1) → (+ (cc  6 0) (cc   5 1))
;; (cc  5 1) → (+ (cc  5 0) (cc   4 1))
;; (cc  4 1) → (+ (cc  4 0) (cc   3 1))
;; (cc  3 1) → (+ (cc  3 0) (cc   2 1))
;; (cc  2 1) → (+ (cc  2 0) (cc   1 1))
;; (cc  1 1) → (+ (cc  1 0) (cc   0 1))
;; (cc  0 1) → Retorna 1.
4
        </code></pre>
        <p>
          Análise de crescimento espacial<sup id="sup5"
            ><a href="#ref5">5</a></sup
          >:
        </p>
        <ul>
          <li>Não há estruturas de dados além das variáveis locais.</li>
          <li>
            A profundidade da recursão é proporcional ao valor de
            <code>amount</code>.
          </li>
          <li>
            As variáveis locais são constantes em cada chamada. Como o espaço é
            dominado pala profundidade de chamadas de <code>amunt</code> o
            crescimento é linear <em>Θ(n)</em>
          </li>
        </ul>
        <p>
          Análise de crescimento temporal<sup id="sup6"
            ><a href="#ref6">6</a></sup
          >:
        </p>

        <ul>
          <li>O algoritmo é recursivo, sem loops explícitos.</li>
          <li>Cada chamada recursiva gera duas novas chamadas:</li>
          <ul>
            <li>Uma para <code>(cc amount (- kinds-of-coins 1))</code></li>
            <li>
              Outra para
              <code
                >(cc (- amount (first-denomination kinds-of-coins))
                kinds-of-coins)</code
              >
            </li>
            <li>
              O número de chamadas cresce exponencialmente com o valor de
              <code>amount</code>, porque cada chamada pode gerar duas novas
              chamadas.
            </li>
          </ul>
        </ul>
        <p>Conclusão:</p>
        <ul>
          <li>Ordem de Crescimento Espacial: <em>Θ(n)</em></li>
          <li>Ordem de Crescimento Temporal: <em>Θ(2<sup>n</sup>)</em></li>
        </ul>
        <h4 id="e_1.15">Exercício 1.15: Resposta</h4>
        <p>
          O procedimento <code>p</code> é aplicado 5 vezes quando
          <code>(sine 12.15)</code>
        </p>
        <pre><code class="language-scheme">
(sine 12.15)
=> (p (sine 4.05))                 ;; 1ª aplicação de p
=> (p (p (sine 1.35)))             ;; 2ª aplicação de p
=> (p (p (p (sine 0.45))))         ;; 3ª aplicação de p
=> (p (p (p (p (sine 0.15)))))     ;; 4ª aplicação de p
=> (p (p (p (p (p (sine 0.05)))))) ;; 5ª aplicação de p
=> (p (p (p (p (p 0.05)))))        ;; Caso base atingido
0.05
        </code></pre>
        <br />
        <br />
        <p>
          No procedimento <code>sine</code>, o argumento <em>a</em> é reduzido
          exponencialmente a cada passo (dividido por 3), o que caracteriza um
          processo de <strong>divisão recursiva</strong>. Isso difere de um
          crescimento linear ou exponencial:
        </p>
        <ul>
          <li>
            Redução por fator constante (3):
            <math>
              <mtable>
                <!-- Explicação da redução -->
                <mtr>
                  <mtd>
                    <mo> </mo>
                    <mfrac>
                      <mi>a</mi>
                      <msup>
                        <mn>3</mn>
                        <mi>k</mi>
                      </msup>
                    </mfrac>
                    <mo>,</mo>
                    <mspace width="0.5em" />
                    <mi>k</mi>
                    <mo>=</mo>
                    <mn>1</mn>
                    <mo>,</mo>
                    <mn>2</mn>
                    <mo>,</mo>
                    <mn>3</mn>
                    <mo>,</mo>
                    <mo>…</mo>
                  </mtd>
                </mtr>
              </mtable>
            </math>
          </li>
        </ul>
        <ul>
          <li>
            Se fosse <em>linear</em>, os passos seriam proporcional a
            <em>a</em> (ex: <em>k = a/3</em>)
          </li>
          <li>
            Se fosse <em>exponencial</em>, passos cresceriam como 3<sup
              style="font-size: 0.7rem !important"
              >k</sup
            >
            (impraticável).
          </li>
        </ul>
        <p>
          Por que logaritmo? O logaritmo resolve equações onde a incógnita está
          no expoente. Na condição
          <math>
            <mfrac>
              <mi>a</mi>
              <msup>
                <mn>3</mn>
                <mi style="font-size: 0.7rem !important">k</mi>
              </msup>
            </mfrac>
            <mo>≤</mo>
            <mn>0.1</mn>
          </math>
          , isolamos 3 <sup style="font-size: 0.8rem !important">k</sup> e
          aplicamos <em>log<sub class="smallsup">3</sub></em> para extrair
          <em>k</em>:
        </p>

        <math display="block">
          <mtable>
            <mtr>
              <mtd>
                <msup>
                  <mn>3</mn>
                  <mi style="font-size: 0.8rem !important">k</mi>
                </msup>
                <mo>≥</mo>
                <mfrac>
                  <mi>a</mi>
                  <mn>0.1</mn>
                </mfrac>
                <mo> ⇒ </mo>
                <mi>k</mi>
                <mo>≥</mo>
                <msub>
                  <mi>log</mi>
                  <mn>3</mn>
                </msub>
                <mo>(</mo>
                <mfrac>
                  <mi>a</mi>
                  <mn>0.1</mn>
                </mfrac>
                <mo>)</mo>
              </mtd>
            </mtr>
          </mtable>
        </math>
        <br />
        <p>
          Simplificação: Usando a propriedade
          <math>
            <msub>
              <mi>log</mi>
              <mn>3</mn>
            </msub>
            <mo>(</mo>
            <mfrac>
              <mi>a</mi>
              <mi>b</mi>
            </mfrac>
            <mo>)</mo>
            <mo>=</mo>
            <msub>
              <mi>log</mi>
              <mn>3</mn>
            </msub>
            <mo>(</mo>
            <mi>a</mi>
            <mo>)</mo>
            <mo>−</mo>
            <msub>
              <mi>log</mi>
              <mn>3</mn>
            </msub>
            <mo>(</mo>
            <mi>b</mi>
            <mo>)</mo>
          </math>
          , obtemos:
        </p>
        <math display="block">
          <mtable>
            <mtr>
              <mtd>
                <msub>
                  <mi>log</mi>
                  <mn>3</mn>
                </msub>
                <mo>(</mo>
                <mfrac>
                  <mi>a</mi>
                  <mn>0.1</mn>
                </mfrac>
                <mo>)</mo>
                <mo>=</mo>
                <msub>
                  <mi>log</mi>
                  <mn>3</mn>
                </msub>
                <mo>(</mo>
                <mi>a</mi>
                <mo>)</mo>
                <mo>−</mo>
                <msub>
                  <mi>log</mi>
                  <mn>3</mn>
                </msub>
                <mo>(</mo>
                <mn>0.1</mn>
                <mo>)</mo>
              </mtd>
            </mtr>
          </mtable>
        </math>
        <br />
        <p>
          O uso do logaritmo é natural já que a redução é exponencial (base 3).
          Isso resulta em uma complexidade espacial e temporal
          <math>
            <mi>Θ</mi>
            <mo>(</mo>
            <mi>log</mi>
            <mo>⁡</mo>
            <mi>a</mi>
            <mo>)</mo>
          </math>
          , muito mais eficiente que soluções lineares (
          <math>
            <mi>Θ</mi>
            <mo>(</mo>
            <mi>a</mi>
            <mo>)</mo>
          </math>
          ) ou exponenciais (
          <math>
            <mi>Θ</mi>
            <mo>(</mo>
            <msup>
              <mn>3</mn>
              <mi style="font-size: 0.8rem !important">k</mi>
            </msup>
            <mo>)</mo>
          </math>
          ).
        </p>

        <h2 id="1.2.4">1.2.4 Exponenciação</h2>

        <h4 id="e_1.16">Exercício 1.16: Resposta</h4>
        <ol>
          <li><strong>Exponenciação:</strong> b<sup>n</sup></li>
          <li>
            <strong
              >Redução por quadrados sucessivos (para <em>n</em> par):</strong
            ><br />
            Se <em>n</em> é par, podemos calcular b<sup>n</sup> de forma mais
            rápida:<br />
            <math xmlns="http://www.w3.org/1998/Math/MathML">
              <msup><mi>b</mi><mi>n</mi></msup> <mo>=</mo>
              <msup>
                <mfenced>
                  <msup>
                    <mi>b</mi>
                    <mfrac>
                      <mi>n</mi>
                      <mn>2</mn>
                    </mfrac>
                  </msup>
                </mfenced>
                <mn>2</mn>
              </msup>
            </math>
            <br />
            <em>Exemplo prático:</em><br />
            <div style="margin-left: 20px">
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msup><mn>2</mn><mn>8</mn></msup> <mo>→</mo>
                <msup><mo>(</mo><mn>2</mn></msup>
                <msup><mo>)</mo><mn>4</mn></msup>
                <msup><mo>)</mo><mn>2</mn></msup> <mo>→</mo>
                <msup><mo>(</mo><mn>4</mn></msup>
                <msup><mo>)</mo><mn>2</mn></msup>
                <msup><mo>)</mo><mn>2</mn></msup> <mo>→</mo>
                <msup><mn>16</mn><mn>2</mn></msup> <mo>=</mo> <mn>256</mn>
              </math>
            </div>
            <p class="emphasis">
              <strong>Por que isso funciona?</strong> Cada vez que elevamos ao
              quadrado, o expoente cai pela metade. Isso reduz o número de
              multiplicações!
            </p>
          </li>
          <li>
            <strong>Passos logarítmicos (por que é rápido?):</strong><br />
            <ul>
              <li>
                <strong>Para <em>n</em> = 8:</strong>
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msup>
                    <mn>2</mn>
                    <mn>8</mn>
                  </msup>
                  <mo>→</mo>
                  <mn>3</mn>
                  <mtext> passos (</mtext>
                  <msub>
                    <mi>log</mi>
                    <mn>2</mn>
                  </msub>
                  <mn>8</mn>
                  <mo>=</mo>
                  <mn>3</mn>
                  <mtext>)</mtext>
                </math>
              </li>
              <li>
                <strong>Para <em>n</em> = 16:</strong>
                <math xmlns="http://www.w3.org/1998/Math/MathML">
                  <msub>
                    <mi>log</mi>
                    <mn class="smallsup">2</mn>
                  </msub>
                  <mn>16</mn>
                  <mo>=</mo>
                  <mn>4</mn>
                  <mtext> passos</mtext>
                </math>
              </li>
            </ul>
            <p class="emphasis">
              <strong>Comparação:</strong> Se <enm></enm> dobrar (ex: 8 → 16), o
              número de passos só aumenta em 1! Isso é o que chamamos de
              crescimento logarítmico.
            </p>
          </li>
          <li>
            <strong>E se <em>n</em> for ímpar?</strong><br />
            <em>Exemplo para 3<sup>5</sup>:</em><br />
            <div style="margin-left: 20px">
              <math xmlns="http://www.w3.org/1998/Math/MathML">
                <msup>
                  <mn>3</mn>
                  <mn>5</mn>
                </msup>
                <mo>=</mo>
                <mn>3</mn>
                <mo>×</mo>
                <msup>
                  <mn>3</mn>
                  <mn>4</mn>
                </msup>
                <mo>→</mo>
                <mn>3</mn>
                <mo>×</mo>
                <msup>
                  <mn>3</mn>
                  <msup>
                    <mn class="smallsup">2</mn>
                    <msup>
                      <mn class="smallsup">2</mn>
                    </msup>
                  </msup>
                </msup>
                <mo>=</mo>
                <mn>3</mn>
                <mo>×</mo>
                <mn>81</mn>
                <mo>=</mo>
                <mn>243</mn>
              </math>
            </div>
            <p class="emphasis">
              <strong>Observação:</strong> Mesmo com um passo extra (para
              ajustar o expoente ímpar), o total de operações ainda é
              proporcional a log(<em>n</em>).
            </p>
          </li>
        </ol>

        <p>Formalização:</p>
        <math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
          <msup>
            <mi>b</mi>
            <mi class="smallsup">n</mi>
          </msup>
          <mo>=</mo>
          <mrow>
            <mo>{</mo>
            <mtable columnalign="left">
              <mtr>
                <mtd>
                  <mn>1</mn>
                  <mtext>se</mtext>
                  <mi>n</mi>
                  <mo>=</mo>
                  <mn>0</mn>
                  <mo>,</mo>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <msup>
                    <mfenced>
                      <msup>
                        <mi>b</mi>
                        <mrow>
                          <mi class="smallsup">n</mi>
                          <mo class="smallsup">/</mo>
                          <mn class="smallsup">2</mn>
                        </mrow>
                      </msup>
                    </mfenced>
                    <mn class="smallsup">2</mn>
                  </msup>
                  <mtext>se</mtext>
                  <mi>n</mi>
                  <mtext>é par,</mtext>
                </mtd>
              </mtr>
              <mtr>
                <mtd>
                  <mi>b</mi>
                  <mo>×</mo>
                  <msup>
                    <mi>b</mi>
                    <mrow>
                      <mi class="smallsup">n</mi>
                      <mo class="smallsup">-</mo>
                      <mn class="smallsup">1</mn>
                    </mrow>
                  </msup>
                  <mtext>se</mtext>
                  <mi>n</mi>
                  <mtext>é ímpar.</mtext>
                </mtd>
              </mtr>
            </mtable>
            <mo
              fence="true"
              stretchy="true"
              form="prefix"
              lspace="0em"
              rspace="0em"
            >
            </mo>
          </mrow>
        </math>
        <br />
        <pre><code class="language-scheme">
(define (expt-with-successive-squares
          base
          exponent
          current-product
        )
  (cond ((= exponent 0) 
          1
        )
        ((even? exponent)
          (expt-with-successive-squares 
            (* base base)
            (/ exponent 2)
            current-product)
        )
        (else
          (expt-with-successive-squares
            base
            (- exponent 1)
            (* base current-product)
          )
        )
  )
)

        </code></pre>

        <h4 id="e_1.17">Exercício 1.17: Resposta</h4>
        <p></p>

        <section id="reference">
          <hr />
          <p id="ref4">
            <sup><a href="#sup4">4</a></sup> Uma função é tail-recursive se a
            última ação executada antes de retornar for uma chamada direta a si
            mesma (sem operações pendentes). Em outras palavras, a chamada
            recursiva é a última operação no fluxo de execução, não havendo
            necessidade de processamento adicional após o retorno da recursão.
          </p>
          <p>
            Por que é importante? Em linguagens que suportam otimização de
            chamada de cauda (TCO), como Scheme, processos tail-recursive são
            executados em espaço constante <em>(Θ(1))</em
            ><sup><a href="#1.2.3">1.2.3</a></sup
            >, ou seja, não acumulam pilha de chamadas. Isso evita estouro de
            pilha (stack overflow) para grandes iterações e torna a recursão tão
            eficiente quanto um loop imperativo.
          </p>
          <p id="ref5">
            <sup><a href="#sup5">5</a></sup> Discas: Ordem de Crescimento
            Temporal:
          </p>
          <ol>
            <li>Conte o número de operações:</li>
            <ul>
              bn
              <li>
                Pergunte-se: "Quantas operações o algoritmo realiza para uma
                entrada de tamanho <code>n</code>?".
              </li>
              <li>
                Como usar: Para loops, conte o número de iterações. Para
                recursão, analise o número de chamadas.
              </li>
            </ul>
            <li>Analise estruturas de repetição (loops):</li>
            <ul>
              <li>
                Loops aninhados geralmente indicam crescimento polinomial (ex.:
                <code>O(n<sup>2</sup>)</code> para dois loops).
              </li>
              <li>
                Como usar: Identifique o número de loops e sua relação com o
                tamanho da entrada.
              </li>
            </ul>
            <li>Verifique chamadas recursivas:</li>
            <ul>
              <li>
                Recursão pode levar a crescimento exponencial
                <code>O(2<sup>n</sup>)</code> ou logarítmico
                <code>O(log n)</code>, dependendo de como o problema é dividido.
              </li>
              <li>
                Como usar: Analise quantas chamadas são geradas em cada passo e
                como o tamanho do problema é reduzido.
              </li>
            </ul>
            <li>Observe operações internas:</li>
            <ul>
              <li>
                Operações dentro de loops ou recursões contribuem para o tempo
                total.
              </li>
              <li>
                Como usar: Multiplique o número de iterações pelo custo das
                operações internas.
              </li>
            </ul>
            <li>Use a notação Big-O:</li>
            <ul>
              <li>
                Simplifique a análise ignorando constantes e termos de menor
                ordem.
              </li>
              <li>Como usar: Foque no termo dominante da função de custo.</li>
            </ul>
          </ol>
          <p id="ref6">
            <sup><a href="#sup6">6</a></sup> Discas: Ordem de Crescimento
            Espacial:
          </p>
          <ol>
            <li>Analise a estrutura de dados utilizada:</li>
            <ul>
              <li>
                Estruturas como arrays, listas ou matrizes ocupam espaço
                proporcional ao tamanho da entrada.
              </li>
              <li>
                b<sup>n</sup> Como usar: Verifique o tamanho das estruturas de
                dados em função de <code>n</code>.
              </li>
            </ul>
            <li>Verifique a profundidade da recursão:</li>
            <ul>
              <li>
                Em algoritmos recursivos, o espaço é determinado pela
                profundidade da pilha de chamadas.
              </li>

              font-size: 0.9em !important;
              <li>
                Como usar: Analise quantas chamadas recursivas são feitas antes
                de atingir o caso base.
              </li>
            </ul>
            <li>Observe variáveis temporárias:</li>
            <ul>
              <li>
                Variáveis criadas em cada iteração ou chamada recursiva
                contribuem para o espaço.
              </li>
              <li>
                Como usar: Conte o número de variáveis e seu tamanho em função
                de <code>n</code>.
              </li>
            </ul>
            <li>Verifique alocações dinâmicas:</li>
            <ul>
              <li>
                Alocações de memória durante a execução (ex.: criar novas
                listas) aumentam o espaço.
              </li>
              <li>
                Como usar: Identifique quanta memória é alocada em função de
                <code>n</code>.
              </li>
            </ul>
            <li>Analise o uso de memória em função da entrada:</li>
            <ul>
              <li>
                Pergunte-se: "Como o uso de memória aumenta à medida que a
                entrada cresce?".
              </li>
              <li>
                Como usar: Relacione o espaço utilizado com o tamanho da entrada
                <code>n</code>.
              </li>
            </ul>
          </ol>
        </section>
      </article>
    </main>
  </body>
</html>
