<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="application-name" content="Notas: MIT 6.001" />
    <meta name="description" content="Blog" />
    <link rel="icon" type="image/png" href="/img/fovicon.svg" />
    <title>JhonFs: Notas MIT 6.001 Cap. 1.2</title>
    <!--CSS-->
    <link rel="stylesheet" href="/css/normilize.css" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/icons.css" />
    <link rel="stylesheet" href="/css/highlight.css" />
    <link rel="stylesheet" href="/css/article.css" />
    <!--SCRIPT-->
    <script src="/js/light.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/markdown.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <main>
      <div id="top"></div>
      <button id="backToTop"><span class="icon_angles_up"></span></button>
      <script src="/js/buttonToTop.js"></script>

      <nav role="navigation">
        <!--Based on the code of Erik Terwan (24th of November 2015, MIT License)-->
        <div id="menuToggle">
          <input type="checkbox" id="menuCheckbox" />

          <!--Icon Hamburguer-->
          <span></span>
          <span></span>
          <span></span>

          <ul id="menu">
            <div class="nav-page">
              <li>
                <a href="1.1 Os Elementos da Programação.html"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_page_previous"
                  ></label
                ></a>
              </li>
              <li>
                <a href="/index.html"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_home"
                  ></label
                ></a>
              </li>
              <li>
                <a href="Guia.html#guia"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_content"
                  ></label
                ></a>
              </li>
              <li>
                <a
                  href="1.3 Formulando Abstrações com Procedimentos de Ordem Superior.html"
                  ><label
                    for="menuCheckbox"
                    onclick="this.parentNode.click();"
                    class="icon_page_next"
                  ></label
                ></a>
              </li>
            </div>
            <hr />
            <li>
              <a href="#1.2"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2 Procedimentos e os Processos que Eles Geram</label
                ></a
              >
            </li>
            <li>
              <a href="#1.2.1"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.1 Recursão Linear e Iteração</label
                ></a
              >
            </li>
            <ul class="exercises">
              <li>
                <a href="#e_1.9"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.9</label
                  ></a
                >
              </li>
              <li>
                <a href="#e_1.10"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.10</label
                  ></a
                >
              </li>
            </ul>
            <li>
              <a href="#1.2.2"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.2 Recursão em Árvore</label
                ></a
              >
            </li>
            <ul class="exercises">
              <li>
                <a href="#e_1.11"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.11</label
                  ></a
                >
              </li>
              <li>
                <a href="#e_1.12"
                  ><label for="menuCheckbox" onclick="this.parentNode.click();">
                    Quest. 1.12</label
                  ></a
                >
              </li>
            </ul>
            <li>
              <a href="#1.2.3"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.3 Ordens de Crescimento</label
                ></a
              >
            </li>
            <li>
              <a href="#1.2.4"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.4 Exponenciação
                </label></a
              >
            </li>
            <li>
              <a href="#1.2.5"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.5 Máximo Divisor Comum</label
                ></a
              >
            </li>
            <li>
              <a href="#1.2.6"
                ><label for="menuCheckbox" onclick="this.parentNode.click();"
                  >1.2.6 Exemplo: Testando Primalidade</label
                ></a
              >
            </li>
            <hr />
            <div class="buttons">
              <a
                href="https://github.com/Jhonatafs"
                class="icon_github"
                target="_blank"
              ></a>
              <a
                href="https://www.linkedin.com/in/jhonfs/"
                class="icon_linkedin"
                target="_blank"
              ></a>
              <a href="#" class="icon_translate disabled"></a>
              <button id="button-light" onclick="lightStatus()">
                <span class="icon_theme"></span>
              </button>
            </div>
          </ul>
        </div>
      </nav>
      <article>
        <h1 id="1.2">1.2 Procedimentos e os Processos que Eles Geram</h1>
        <p>
          O que é um bom programador? Um bom programador é definido por
          habilidades que vão além do conhecimento técnico básico (como
          operações e sintaxe). Os elementos essenciais são:
        </p>
        <ol>
          <li>Capacidade de Visualizar Processos</li>
          <ul>
            <li>
              <strong>Antecipar consequências:</strong> Saber prever como um
              procedimento ou linha de código afetará o fluxo do programa, a
              eficiência, a manutenção e o resultado.
            </li>
            <li>
              <strong>Simulação mental:</strong> Entender como o processo gerado
              por um código se desenrola, passo a passo, incluindo estados
              intermediários e possíveis erros.
            </li>
          </ul>
          <li>Experiência com Padrões e Estratégias</li>
          <ul>
            <li>
              <strong>Conhecimento de "movimentos valiosos":</strong> Dominar
              padrões de projeto, algoritmos eficientes e boas práticas.
            </li>
            <li>
              <strong>Abstração eficaz:</strong> Saber combinar operações
              primitivas em procedimentos úteis e reutilizáveis.
            </li>
          </ul>
          <li>Planejamento Sintético e Raciocínio Lógico</li>
          <ul>
            <li>
              <strong>Pensamento reverso:</strong> Trabalhar de trás para frente
              a partir do resultado desejado (como um fotógrafo planeja
              exposição).
            </li>
            <li>
              <strong>Controle do processo:</strong> Garantir execução ordenada
              e confiável do programa.
            </li>
          </ul>
          <li>Aprendizado Contínuo com a Prática</li>
          <ul>
            <li>
              <strong>Experiência acumulada:</strong> Desenvolver intuição
              através da exposição a cenários complexos.
            </li>
            <li>
              <strong>Adaptação:</strong> Ajustar estratégias conforme o
              contexto (como técnicas fotográficas).
            </li>
          </ul>
        </ol>

        <h2 id="1.2.1">1.2.1 Recursão Linear e Iteração</h2>
        <ol>
          <li><mark>Processo</mark> Recursivo Linear:</li>
          <ul>
            <li>
              Expansão (acúmulo de operações) seguida de contração (execução das
              operações).
            </li>
            <li>
              Requer memória proporcional a <em>n</em> (crescimento linear),
              pois o interpretador rastreia a cadeia de operações pendentes.
            </li>
          </ul>
          <li><mark>Processo</mark> Iterativo Linear:</li>
          <ul>
            <li>Usa variáveis de estado atualizadas iterativamente:</li>
            <li>
              Mantém estado fixo, evoluindo em espaço constante (memória fixa),
              mesmo para grandes <em>n</em>.
            </li>
          </ul>
        </ol>
        <p>
          Sintaxe recursiva (porém com chamadas de cauda) gera processo
          iterativo. Mantendo um espaço constante, pois o estado é totalmente
          descrito pelas variáveis a cada passo. Exemplos em outras linguagens:
          o <code>for</code> e o <code>while</code>. A recursão sintática
          (código que chama a si) não implica necessariamente um processo
          recursivo (com crescimento de memória). Um procedimento recursivo pode
          gerar um processo iterativo se for tail-recursive<sup id="sup4"
            ><a href="#ref4">4</a></sup
          >
          (recursão de cauda).
        </p>
        <hr />
        <h4 id="e_1.9">Exercício 1.9: Resposta</h4>
        <p>Processo Recursivo:</p>
        <pre><code class="language-scheme">
(+ 4 5)                         ;; Chamada do procedimento 1
(inc (+ 3 5))                   ;; Passo 1: inc é adiado
(inc (inc (+ 2 5)))             ;; Passo 2: incs acumulam
(inc (inc (inc (+ 1 5))))       ;; Passo 3
(inc (inc (inc (inc (+ 0 5))))) ;; Passo 4: caso-base (a=0)
(inc (inc (inc (inc 5))))       ;; Passo 5: contração começa
(inc (inc (inc 6)))             ;; Passo 6
(inc (inc 7))                   ;; Passo 7
(inc 8)                         ;; Passo 8
9                               ;; Resultado
        </code></pre>
        <p>Processo Interativo:</p>
        <pre><code class="language-scheme">
(+ 4 5) ;; Chamada do procedimento 2
(+ 3 6) ;; Passo 1: atualizar a e b
(+ 2 7) ;; Passo 2
(+ 1 8) ;; Passo 3
(+ 0 9) ;; Passo 4: caso-base (a=0)
9       ;; Resultado
        </code></pre>
        <h4 id="e_1.10">Exercício 1.10: Resposta</h4>
        <p>Os valores das expressões são:</p>
        <pre><code class="language-scheme">
(A 1 10)
1024 ;; Resposta

(A 2 4)
65536 ;; Resposta

(A 3 3)
65536 ;; Resposta
        </code></pre>
        <p>
          Definições matemáticas para <code>(f n)</code>, <code>(g n)</code>,
          <code>(h n)</code>, <code>(k n)</code>
        </p>
        <pre><code class="language-scheme">
(f n) ;; Sendo n > 0
;; f(n) = 2n

(g n) ;; Sendo n > 0
;; g(n) = 2^n

(h n) ;; Sendo n > 0
;; h(n) = 2↑↑n = 2^(h(n-1)) = 2^(2^(h(n-1))) = 2^(2^(2^(...^(2))))
;; Exemplo:
;;;; h(1) = 2
;;;; h(2) = 2^2 = 4
;;;; h(3) = 2^(2^2) = 16
;;;; h(4) = 2^(2^(2^2)) = 65536

;; (k n) => 5n^2
        </code></pre>
        <h2 id="1.2.2">1.2.2 Recursão em Árvore</h2>
        <ul>
          <li>
            Padrão de função recursiva que gera estruturas semelhantes a
            árvores.
          </li>
          <li>
            Cada chamada recursiva cria "ramos" que se dividem até atingir um
            caso-base.
          </li>
          <li>
            O número de passos cresce rapidamente, proporcional ao número de nós
            na árvore. O crescimento temporal é exponencial.
          </li>
          <li>
            O espaço necessário cresce proporcional à profundidade da árvore.
            Apenas os nós ativos na recursão são armazenados na memória. O
            crescimento espacial é linear.
          </li>
          <li>
            É natural para problemas com estruturas hierárquicas (ex: árvores de
            dados). Mas é ineficiente para entradas grandes devido a cálculos
            redundantes e aí entra a função interativa.
          </li>
        </ul>
        <h4 id="e_1.11">Exercício 1.11: Resposta</h4>
        <p>Regra:</p>
        <math display="block">
          <mrow>
            <mi>f</mi>
            <mo>(</mo>
            <mi>n</mi>
            <mo>)</mo>
            <mo>=</mo>
            <mrow>
              <mo>{</mo>
              <mtable columnalign="left left" rowspacing="0.2em">
                <mtr>
                  <mtd>
                    <mi>n</mi>
                  </mtd>
                  <mtd>
                    <mtext>para</mtext>
                    <mi>n</mi>
                    <mo><</mo>
                    <mn>3</mn>
                  </mtd>
                </mtr>
                <mtr>
                  <mtd>
                    <mi>f</mi>
                    <mo>(</mo>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>1</mn>
                    <mo>)</mo>
                    <mo>+</mo>
                    <mn>2</mn>
                    <mi>f</mi>
                    <mo>(</mo>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>2</mn>
                    <mo>)</mo>
                    <mo>+</mo>
                    <mn>3</mn>
                    <mi>f</mi>
                    <mo>(</mo>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>3</mn>
                    <mo>)</mo>
                  </mtd>
                  <mtd>
                    <mtext>para</mtext>
                    <mi>n</mi>
                    <mo>≥</mo>
                    <mn>3</mn>
                  </mtd>
                </mtr>
              </mtable>
              <mo>}</mo>
            </mrow>
          </mrow>
        </math>
        <br />
        <p>Para <em>f(n)</em> como procedimento recursivo:</p>
        <pre><code class="language-scheme">
(define (f n)
  (if (n &lt; 3)
      n
      (+ (f (- n 1))
         (* 2 (f (- n 2)))
         (* 3 (f (- n 3)))
      )
  )
)
        </code></pre>
        <br />
        <br />
        <p>Para <em>f(n)</em> como procedimento interativo:</p>
        <ol>
          <li>Se n &lt; 3 é retornado n</li>
          <pre><code class="language-scheme">
(if (n &lt; 3) n ...)
          </code></pre>
          <li>Preciso armazenar os valores:</li>
          <ul>
            <li><code>f(n-1) = a</code></li>
            <li><code>f(n-3) = b</code></li>
            <li><code>f(n-2) = c</code></li>
          </ul>
          <li>O valor base é quando <code>n = 3</code>, então:</li>
          <ul>
            <li>Valor inicial: <code>a = 2</code></li>
            <li>Valor inicial: <code>b = 1</code></li>
            <li>Valor inicial: <code>c = 0</code></li>
          </ul>
          <li>
            Quando <code>n &gt; 3</code> é preciso calcular várias vezes
            <em>f(n)</em>, para isso preciso atualiza os valores durante o
            processo a fim de não criar um processo recursivo, onde:
            <ul>
              <li><code>c = b</code></li>
              <li><code>b = a</code></li>
              <li><code>a = f(n-1) + 2f(n-2) + 3f(n-3)</code></li>
            </ul>
            Logo preciso de um loop e uma variável de controle que pare o loop
            quando igual ao valor de <code>n</code>, já que o cálculo será feito
            a partir do valor de base e o cálculo repetirá n vezes:
          </li>
        </ol>

        <pre><code class="language-scheme">
(define (loop controle a b c)
  (if (= n controle)
      controle
      (loop (+ 1 controle)
            (+ a (* 2 b) (* 3 c))
            a                  
            b
            
      )
  )
)
        </code></pre>
        <br />
        <br />
        <p>O Procedimento completo fica:</p>
        <pre><code class="language-scheme">
(define (i n)
  (define (loop controle a b c)
    (if (= n controle)
        a                           ;; Aqui retorna o valor do cálculo
        (loop                       ;; Chamada para atualizar os valores
              (+ 1 controle)        ;; Mecanismo de stop
              (+ a (* 2 b) (* 3 c)) ;; Novo 'a'
              a                     ;; Novo 'b'                  
              b                     ;; Novo 'c'
        )
    )
  )

  (if (&lt; n 3)
      3
                                    ;; Aqui determino o valor inicial de 'a',
                                    ;; 'b', 'c' e da variável de controle:
                                    ;; (loop &lt;a&gt; &lt;b&gt; &lt;c&gt; &lt;controle&gt;)  
      (loop 2 2 1 0)   
  )
)
        </code></pre>
        <h4 id="e_1.12">Exercício 1.12: Resposta</h4>
        <ul>
          <li>O triangulo é formado por linhas (l)</li>
          <li>
            O número da linha determina quantos números haverá nela, exemplo:
          </li>
          <ul>
            <li>Linha 1 = 1 número</li>
            <li>Linha 2 = 2 números</li>
            <li>Linha 3 = 3 números</li>
            <li>...</li>
          </ul>
          <li>
            A primeira posição <code>p</code> na linha pode ser zero ou 1, vou
            usar 1 como posição inicial, pois se eu usar 0 o número de elementos
            em cada linha será <code>l + 1</code> e não <code>l</code>. O Que
            evita eu ter que implementar algo para deixar natural para o usuário
            final.
          </li>
          <li>
            As outras posição é definida pela soma de 2 números da linha de
            anterior, sendo:
            <ul>
              <li>
                O primeiro número da mesma posição:
                <pre><code class="language-scheme">
(+ (- l 1)  ;; Linha Anterior
   (p))     ;; Posição do número atual
                </code></pre>
              </li>
              <li>
                O segundo número da posição anterior
                <pre><code class="language-scheme">
(+ (- l 1)  ;; Linha Anterior
   (+ p 1)) ;; Posição do número atual
                </code></pre>
              </li>
            </ul>
          </li>
          <li>Então a função fica:</li>
          <pre><code class="language-scheme">
(define (pascal l p)
  (cond 
    ;; Verifica se a posição é inválida
    ((or (&lt; p 1) (> p l)) 0) ;; Retorna 0 para posições inválidas

    ;; Converte linhas negativas para positivas
    ((&lt;= l 0) (pascal (abs l) p)) ;; Evita linhas *negativas

    ;; Casos-base: bordas da linha
    ((= p 1) 1) ;; Primeira posição da linha → 1
    ((= p l) 1) ;; Última posição da linha → 1

    ;; Passo recursivo: soma dos dois elementos acima
    (else 
      (+ (pascal (- l 1) p)        ;; Elemento acima (n-1, p)
          (pascal (- l 1) (- p 1))  ;; Elemento acima à esquerda (n-1, p-1)
      )
    ) 
  )      
)      
          </code></pre>
        </ul>

        <h4 id="e_1.13">Exercício 1.13: Resposta</h4>
        <p>...</p>

        <!--
          <h2 id="1.2.4">1.2.4 Exponenciação</h2>
          <h2 id="1.2.5">1.2.5 Máximo Divisor Comum</h2>
          <h2 id="1.2.6">1.2.6 Exemplo: Teste de Primalidade</h2>
          -->
        <h2 id="1.2.3">1.2.3 Ordens de Crescimento</h2>
        <p>
          Ordens de Crescimento são uma maneira de descrever como o consumo de
          recursos (como tempo ou espaço) de um processo computacional aumenta à
          medida que o tamanho do problema cresce. Imagine que você tem um
          algoritmo que leva R(n) passos para ser executado, onde <em>n</em> é o
          tamanho da entrada. Se <em>R(n) = Θ(n²)</em>, isso significa que, para
          entradas grandes, o tempo de execução do seu algoritmo crescerá
          aproximadamente como o quadrado do tamanho da entrada:
        </p>

        <ol>
          <li>
            <strong>Processo Linear</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(n)</em> passos, o número de
                operações cresce linearmente com <em>n</em>.
              </li>
              <li>
                <strong>Exemplo</strong>: Se você dobrar o tamanho do problema
                <em>n</em>, o número de operações também dobrará.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Quadrático</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(n<sup>2</sup>)</em> passos, o número
                de operações cresce quadraticamente com <em>n</em>.
              </li>
              <li>
                <strong>Exemplo</strong>: Dobrar o tamanho do problema
                quadruplicará o número de operações.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Exponencial</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(ϕ<sup>n</sup>)</em> passos (onde
                <em>ϕ</em> é a razão áurea), o número de operações cresce
                exponencialmente com <em>n</em>.
              </li>
              <li>
                <strong>Exemplo</strong>: Cada incremento no tamanho do problema
                multiplicará o número de operações por um fator constante.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Logarítmico</strong>:
            <ul>
              <li>
                Se um processo requer <em>Θ(log n)</em>passos, o número de
                operações cresce lentamente, mesmo quando <em>n</em> aumenta
                significativamente.
              </li>
              <li>
                <strong>Exemplo</strong>: Dobrar o tamanho do problema aumenta o
                número de operações por uma quantidade constante.
              </li>
            </ul>
          </li>
          <li>
            <strong>Processo Não Primitivo-Recursivo</strong>:
            <ul>
              <li>
                Se um processo requer uma função
                <strong>não primitiva-recursiva</strong>, como a Função de
                Ackermann <em>A(n, n)</em>, o número de operações cresce de
                forma extremamente rápida, ultrapassando qualquer função
                primitiva-recursiva.
              </li>
              <li>
                <strong>Exemplo</strong>: A Função de Ackermann
                <em>A(4, n) </em> já produz números tão grandes que são
                praticamente incomputáveis para valores modestos de <em>n</em>.
              </li>
              <li>
                <strong>Característica</strong>: O crescimento é tão acelerado
                que não pode ser descrito por funções como exponenciais,
                fatoriais ou torres de potências.
              </li>
            </ul>
          </li>
        </ol>

        <table>
          <thead>
            <tr>
              <th>Tipo de Processo</th>
              <th>Ordem de Crescimento</th>
              <th>Exemplo de Comportamento</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>Logarítmico</strong></td>
              <td><em>Θ(log n)</em></td>
              <td>Crescimento muito lento.</td>
            </tr>
            <tr>
              <td><strong>Linear</strong></td>
              <td><em>Θ(n)</em></td>
              <td>Crescimento proporcional ao tamanho do problema.</td>
            </tr>
            <tr>
              <td><strong>Quadrático</strong></td>
              <td><em>Θ(n<sup>2</sup>)</em></td>
              <td>Crescimento rápido, mas gerenciável.</td>
            </tr>
            <tr>
              <td><strong>Exponencial</strong></td>
              <td><em>Θ(ϕ<sup>n</sup>)</em></td>
              <td>Crescimento explosivo, impraticável para n grande.</td>
            </tr>
            <tr>
              <td><strong>Não Primitivo-Recursivo</strong></td>
              <td><em>Θ(A(n, n))</em></td>
              <td>Crescimento extremamente rápido, incomputável.</td>
            </tr>
          </tbody>
        </table>
        <h4 id="e_1.14">Exercício 1.14: Resposta</h4>
        <p>Árvore ilustrativa do processo <code>count-change</code>:</p>
        <figure>
          <figcaption>
            Figura retirada de
            <a
              href="https://sicp-solutions.net/post/sicp-solution-exercise-1-14/"
              target="_blank"
              >Sicp-Solutions</a
            >
          </figcaption>
          <img src="img/fig-e_1.14.svg" alt="" />
        </figure>
        <p>A Imagem representa:</p>
        <pre><code class="language-scheme">
(count-change 11) ;; Chamada Inicial
;; (cc 11 5) → (+ (cc 11 4) (cc -39 5))
;; (cc 11 4) → (+ (cc 11 3) (cc -14 4))
;; (cc 11 3) → (+ (cc 11 2) (cc   1 3))
;; (cc 11 2) → (+ (cc 11 1) (cc   6 2))
;; (cc 11 1) → (+ (cc 11 0) (cc  10 1))
;; (cc 10 1) → (+ (cc 10 0) (cc   9 1))
;; (cc  9 1) → (+ (cc  9 0) (cc   8 1))
;; (cc  8 1) → (+ (cc  8 0) (cc   7 1))
;; (cc  7 1) → (+ (cc  7 0) (cc   6 1))
;; (cc  6 1) → (+ (cc  6 0) (cc   5 1))
;; (cc  5 1) → (+ (cc  5 0) (cc   4 1))
;; (cc  4 1) → (+ (cc  4 0) (cc   3 1))
;; (cc  3 1) → (+ (cc  3 0) (cc   2 1))
;; (cc  2 1) → (+ (cc  2 0) (cc   1 1))
;; (cc  1 1) → (+ (cc  1 0) (cc   0 1))
;; (cc  0 1) → Retorna 1.
4
        </code></pre>
        <p>
          Análise de crescimento espacial<sup id="sup5"
            ><a href="#ref5">5</a></sup
          >:
        </p>
        <ul>
          <li>Não há estruturas de dados além das variáveis locais.</li>
          <li>
            A profundidade da recursão é proporcional ao valor de
            <code>amount</code>.
          </li>
          <li>
            As variáveis locais são constantes em cada chamada. Como o espaço é
            dominado pala profundidade de chamadas de <code>amunt</code> o
            crescimento é linear <em>Θ(n)</em>
          </li>
        </ul>
        <p>Análise de crescimento temporal:</p>
        <ul>
          <li>O algoritmo é recursivo, sem loops explícitos.</li>
          <li>Cada chamada recursiva gera duas novas chamadas:</li>
          <ul>
            <li>Uma para <code>(cc amount (- kinds-of-coins 1))</code></li>
            <li>
              Outra para
              <code
                >(cc (- amount (first-denomination kinds-of-coins))
                kinds-of-coins)</code
              >
            </li>
            <li>
              O número de chamadas cresce exponencialmente com o valor de
              <code>amount</code>, porque cada chamada pode gerar duas novas
              chamadas.
            </li>
          </ul>
          <p>Conclusão:</p>
          <ul>
            <li>Ordem de Crescimento Espacial: <em>Θ(n)</em></li>
            <li>Ordem de Crescimento Temporal: <em>Θ(2<sup>n</sup>)</em></li>
          </ul>
        </ul>
        <section id="reference">
          <hr />
          <p id="ref4">
            <sup><a href="#sup4">4</a></sup> Uma função é tail-recursive se a
            última ação executada antes de retornar for uma chamada direta a si
            mesma (sem operações pendentes). Em outras palavras, a chamada
            recursiva é a última operação no fluxo de execução, não havendo
            necessidade de processamento adicional após o retorno da recursão.
          </p>
          <p>
            Por que é importante? Em linguagens que suportam otimização de
            chamada de cauda (TCO), como Scheme, processos tail-recursive são
            executados em espaço constante <em>(Θ(1))</em
            ><sup><a href="#1.2.3">1.2.3</a></sup
            >, ou seja, não acumulam pilha de chamadas. Isso evita estouro de
            pilha (stack overflow) para grandes iterações e torna a recursão tão
            eficiente quanto um loop imperativo.
          </p>
          <p id="ref5">
            <sup><a href="#sup5">5</a></sup> Discas:
          </p>
          <ul id="ref5">
              <li><sup><a href="#sup5">5</a></sup> Discas: Ordem de Crescimento Temporal:</li>
              <ol>
                <li>
                  Conte o número de operações:
                  <ul>
                    <li>
                      Pergunte-se: "Quantas operações o algoritmo realiza para uma
                      entrada de tamanho <code>n</code>?".
                    </li>
                    <li>Como usar: Para loops, conte o número de
                      iterações. Para recursão, analise o número de chamadas.
                    </li>
                  </ul>
                </li>
                <li>Analise estruturas de repetição (loops):
                  <ul>
                    <li>
                      Loops aninhados geralmente indicam crescimento polinomial
                      (ex.: <code>O(n<sup>2</sup>)</code> para dois loops).
                    </li>
                    <li>
                      <strong>Como usar:</strong> Identifique o número de loops e
                      sua relação com o tamanho da entrada.
                    </li>
                  </ul>
                </li>
                <li>
                  <strong>Verifique chamadas recursivas:</strong>
                  <p>
                    Recursão pode levar a crescimento exponencial
                    <code>O(2<sup>n</sup>)</code> ou logarítmico
                    <code>O(log n)</code>, dependendo de como o problema é
                    dividido.
                  </p>
                  <p>
                    <strong>Como usar:</strong> Analise quantas chamadas são
                    geradas em cada passo e como o tamanho do problema é
                    reduzido.
                  </p>
                </li>
                <li>
                  <strong>Observe operações internas:</strong>
                  <p>
                    Operações dentro de loops ou recursões contribuem para o
                    tempo total.
                  </p>
                  <p>
                    <strong>Como usar:</strong> Multiplique o número de
                    iterações pelo custo das operações internas.
                  </p>
                </li>
                <li>
                  <strong>Use a notação Big-O:</strong>
                  <p>
                    Simplifique a análise ignorando constantes e termos de menor
                    ordem.
                  </p>
                  <p>
                    <strong>Como usar:</strong> Foque no termo dominante da
                    função de custo.
                  </p>
                </li>
              </ol>
            </li>
          </ul>
            <ul id="ref6">
              <li><sup><a href="#sup6">6</a></sup> Discas: Ordem de Crescimento Espacial:</li>
              <ol>
                <li>
                  <strong>Analise a estrutura de dados utilizada:</strong>
                  <p>
                    Estruturas como arrays, listas ou matrizes ocupam espaço
                    proporcional ao tamanho da entrada.
                  </p>
                  <li>
                    <strong>Como usar:</strong> Verifique o tamanho das
                    estruturas de dados em função de <code>n</code>.
                  </li>
                </li>
                <li>
                  <strong>Verifique a profundidade da recursão:</strong>
                  <li>
                    Em algoritmos recursivos, o espaço é determinado pela
                    profundidade da pilha de chamadas.
                  </li>
                  <li>
                    <strong>Como usar:</strong> Analise quantas chamadas
                    recursivas são feitas antes de atingir o caso base.
                  </li>
                </li>
                <li>
                  <strong>Observe variáveis temporárias:</strong>
                  <li>
                    Variáveis criadas em cada iteração ou chamada recursiva
                    contribuem para o espaço.
                  </li>
                  <li>
                    <strong>Como usar:</strong> Conte o número de variáveis e
                    seu tamanho em função de <code>n</code>.
                  </li>
                </li>
                <li>Verifique alocações dinâmicas:</li>
                <ul>
                  <li>
                    Alocações de memória durante a execução (ex.: criar novas
                    listas) aumentam o espaço.
                </li>
                  <li>
                    <strong>Como usar:</strong> Identifique quanta memória é
                    alocada em função de <code>n</code>.
                  </li>
                </ul>
                <li
                    >Analise o uso de memória em função da entrada:</li
                  >
                  <ul>
                  
                    <li>
                    Pergunte-se: "Como o uso de memória aumenta à medida que a
                    entrada cresce?".
                  </li>
                  <li>
                    <strong>Como usar:</strong> Relacione o espaço utilizado com
                    o tamanho da entrada <code>n</code>.
                  </li>
                </ul>
              </ol>
            </li>
          </ul>
        </section>
      </article>
    </main>
  </body>
</html>
