<!DOCTYPE html>
<html lang="pt-br">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Estrutura e Interpretação de Programas de Computador</title>
     <link rel="icon" type="image/png" href="/images/favicon.png" />
     <link rel="stylesheet" href="../css/normalize.css">
     <link rel="stylesheet" href="../css/book-page.css">
     <link rel="stylesheet" href="../css/navigation.css">
<script src="https://kit.fontawesome.com/0c2f8cb29c.js" crossorigin="anonymous"></script>
</head>
<body>
     <nav id="navbar-book">
     <ul>
          <!--Come back-->
          <li><a class="enabled" href="9.html"><i class="fa-solid fa-circle-left"></i></a></li>
          <!--Home-->
          <li><a class="enabled" href="/index.html"><i class="fa-solid fa-house"></i></a></li>
          <!--Cover-->
          <li><a class="enabled" href="../book.html"><i class="fa-solid fa-book"></i></a></li>
          <!--Content-->
          <li><a class="enabled" href="4.html"><i class="fa-solid fa-list-ul"></i></a></li>
          <!--Next-->
          <li><a class="enabled" href="11.html"><i class="fa-solid fa-circle-right"></i></i></a></li>
     </ul>
     </nav>
     <main>
          <h1 id="1.1">1.1 Os Elementos da Programação</h1>
          <p>Uma linguagem de programação poderosa é mais do que apenas um meio de instruir um computador a executar tarefas. A linguagem também serve como uma estrutura dentro da qual organizamos nossas ideias sobre processos. Assim, quando descrevemos uma linguagem, devemos prestar atenção especial aos meios que a linguagem fornece para combinar ideias simples para formar ideias mais complexas. Toda linguagem poderosa tem três mecanismos para realizar isso:</p>
          <ul>
               <li><strong>expressões primitivas</strong>, que representam as entidades mais simples com as quais a linguagem se preocupa,</li>
               <li><strong>meios de combinação</strong>, pelos quais elementos compostos são construídos a partir de outros mais simples, e</li>
               <li><strong>meios de abstração</strong>, pelos quais elementos compostos podem ser nomeados e manipulados como unidades.</li>
          </ul> 
          <p>Na programação, lidamos com dois tipos de elementos:procedimentos e dados. (Mais tarde descobriremos que eles não são realmente tão distintos.) Informalmente, dados são "coisas" que queremos manipular, e procedimentos são descrições das regras para manipular os dados. Assim, qualquer linguagem de programação poderosa deve ser capaz de descrever dados primitivos e procedimentos primitivos e deve ter métodos para combinar e abstrair procedimentos e dados.</p>  
          <p>Neste capítulo trataremos apenas de questões simplesdados numéricos para que possamos nos concentrar nas regras para construir procedimentos.<sup><a href="">4</a></sup> Nos capítulos posteriores, veremos que essas mesmas regras nos permitem construir procedimentos para manipular dados compostos também.</p>
          <h2 id="1.1.1">1.1.1 Expressões</h2>  
          <p>Uma maneira fácil de começar a programar é examinar algumas interações típicas com um interpretador para o dialeto Scheme do Lisp. Imagine que você está sentado em um terminal de computador. Você digita uma expressão e o interpretador responde exibindo o resultado de sua avaliação dessa expressão.</p>  
          <p>Um tipo de expressão primitiva que você pode digitar é um número. (Mais precisamente, a expressão que você digita consiste nos numerais que representam o número na base 10.) Se você apresentar ao Lisp um número</p>  
          <p class="code">
              <span>486</span>
          </p>
          <p>o intérprete responderá imprimindo<sup><a href="">5</a></sup></p>  
          <p class="code">
               <span class="code-result">486</span>
          </p>
          <p>Expressões que representam números podem ser combinadas com umexpressão que representa umaprocedimento primitivo (como + ou * ) para formar uma expressão composta que representa a aplicação do procedimento a esses números. Por exemplo:</p>
          <p class="code">
               <span>(+ 137 349)</span>
               <span class="code-result">486</span>
               <span>(- 1000 334)</span>
               <span class="code-result">666</span>
               <span>(* 5 99)</span>
               <span class="code-result">495</span>
               <span>(/ 10 5)</span>
               <span class="code-result">2</span>
               <span>(+ 2,7 10)</span>
               <span class="code-result">12,7</span>
          </p>
          <p>Expressões como estas, formadas pordelimitando uma lista de expressões entre parênteses para denotaraplicação de procedimento, são chamados de combinações . O elemento mais à esquerda na lista é chamado deoperador , e os outros elementos são chamadosoperandos . Oso valor de uma combinação é obtido aplicando o procedimento especificado pelo operador ao argumentos que são os valores dos operandos.</p>  
          <p>A convenção de colocar o operador à esquerda dos operandos é conhecida comonotação de prefixo , e pode ser um pouco confuso no início porque se afasta significativamente da convenção matemática habitual. A notação de prefixo tem várias vantagens, no entanto. Uma delas é que pode acomodarprocedimentos que podem receber um número arbitrário de argumentos, como nos exemplos a seguir:</p>  
          <p class="code">
               <span>(+ 21 35 12 7)</span>
               <span class="code-result">75</span>
               <span>(* 25 4 12)</span>
               <span class="code-result">1200</span>
          </p> 
          <p>Não pode surgir nenhuma ambiguidade, porque o operador é sempre o elemento mais à esquerda e toda a combinação é delimitada pelos parênteses.</p>  
          <p>Uma segunda vantagem da notação de prefixo é que ela se estende de maneira direta para permitir que combinações sejam aninhadas , ou seja, para ter combinações cujos elementos são eles próprios combinações:</p>
          <p class="code">
               <span>(+ (* 3 5) (- 10 6))</span>
               <span class="code-result">19</span>
          </p>
          <p>Não há limite (em princípio) para a profundidade de tal aninhamento e para a complexidade geral das expressões que o interpretador Lisp pode avaliar. Somos nós, humanos, que ficamos confusos com expressões ainda relativamente simples, como</p>
          <p class="code">
               <span>(+ (* 3 (+ (* 2 4) (+ 3 5))) (+ (- 10 7) 6))</span>
          </p>
          <p>que o intérprete prontamente avaliaria como sendo 57. Podemos nos ajudar escrevendo tal expressão na forma</p>
          <p class="code">
               <span>(+ (* 3 <br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ (* 2 4) <br>
                    &nbsp;&nbsp;&nbsp;(+ 3 5))) <br>
                    &nbsp;&nbsp;&nbsp;(+ (- 10 7) <br>
                    &nbsp;&nbsp;&nbsp;6))</span>
          </p>
          <p>seguindo uma convenção de formatação conhecida comopretty-printing , em que cada combinação longa é escrita de modo que os operandos sejam alinhados verticalmente. Os recuos resultantes exibem claramente a estrutura da expressão.<sup><a href="">6</a></sup></p>  
          <p>Mesmo com expressões complexas, o interpretador sempre opera no mesmo ciclo básico: ele lê uma expressão do terminal, avalia a expressão e imprime o resultado. Esse modo de operação é frequentemente expresso dizendo que o interpretador roda em um <em>loop read-eval-print</em>. Observe em particular que não é necessário instruir explicitamente o interpretador a imprimir o valor da expressão.<sup><a href="">8</a></sup></p>  
          <h2 id="1.1.2">1.1.2 Nomeação e ambiente</h2>
          <p>Um aspecto crítico de uma linguagem de programação é o meio que ela fornece para usar nomes para se referir a objetos computacionais. Dizemos que o nome identifica um <em>variável</em> cuja <em>valor</em> é o objeto.</p>  
          <p>No dialeto Scheme do Lisp, nomeamos as coisas com <em>definir</em> . Digitação</p>
          <p class="code">
               <span>(defina tamanho 2)</span>
          </p>
          <p>faz com que o interpretador associe o valor 2 ao nome size<sup><a href="">8</a></sup>. Uma vez que o nome size tenha sido associado ao número 2, podemos nos referir ao valor 2 pelo nome:</p>  
          <p class="code">
               <span>tamanho <br>
                    &nbsp;&nbsp;&nbsp;2 <br>
                    &nbsp;&nbsp;&nbsp;(*5 tamanho) <br>
                    &nbsp;&nbsp;&nbsp;10</span>
          </p> 
          <p>Aqui estão mais exemplos do uso de <em>define</em>:</p>  
          <p class="code">
               <span>(define pi 3,14159)</span>
               <span>(define raio 10)</span>
               <span>(* pi (* raio raio))</span>
               <span class="code-result">314,159</span>
               <span>(define circunferência (* 2 pi raio))</span>
               <span>circunferência</span>
               <span class="code-result">62,8318</span>
          </p>
          <p><em>Define</em> é o meio mais simples de abstração da nossa linguagem, pois nos permite usar nomes simples para nos referirmos aos resultados de operações compostas, como a circunferência computada acima. Em geral, objetos computacionais podem ter estruturas muito complexas, e seria extremamente inconveniente ter que lembrar e repetir seus detalhes cada vez que quisermos usá-los. De fato, programas complexos são construídos construindo, passo a passo, objetos computacionais de complexidade crescente. O interpretador torna essa construção de programa passo a passo particularmente conveniente porque associações nome-objeto podem ser criadas incrementalmente em interações sucessivas. Esse recurso incentiva o desenvolvimento incremental e teste de programas e é em grande parte responsável pelo fato de que um programa Lisp geralmente consiste em um grande número de procedimentos relativamente simples.</p>  
          <p>Deve ficar claro que a possibilidade de associar valores a símbolos e depois recuperá-los significa que o interpretador deve manter algum tipo de memória que acompanhe os pares nome-objeto. Essa memória é chamada demeio ambiente (mais precisamente oambiente global , pois veremos mais tarde que uma computação pode envolver vários ambientes diferentes)<sup><a href="">9</a></sup>.</p>
          <h2 id="1.1.3">1.1.3 Avaliando Combinações</h2>
          <p>Um dos nossos objetivos neste capítulo é isolar questões sobre pensar proceduralmente. Como um caso em questão, vamos considerar que, ao avaliar combinações, o intérprete está ele próprio seguindo um procedimento.</p>
          <ul>
               <li>Para avaliar uma combinação, faça o seguinte:</li>
               <ol style="list-style: decimal;">
                    <li>Avalie as subexpressões da combinação.</li>
                    <li>Aplique o procedimento que é o valor da subexpressão mais à esquerda (o operador) aos argumentos que são os valores das outras subexpressões (os operandos).</li>
               </ol>
          </ul>
          <p>Mesmo esta regra simples ilustra alguns pontos importantes sobre processos em geral. Primeiro, observe que o primeiro passo determina que, para realizar o processo de avaliação para uma combinação, devemos primeiro executar o processo de avaliação em cada elemento da combinação. Assim, a regra de avaliação érecursiva por natureza; ou seja, inclui, como uma de suas etapas, a necessidade de invocar a própria regra<sup><a href="">10</a></sup>.</p>  
          <p>Observe quão sucintamente a ideia de recursão pode ser usada para expressar o que, no caso de uma combinação profundamente aninhada, seria visto como um processo bastante complicado. Por exemplo, avaliar</p>
          <p class="code">
               <span>(* (+ 2 (* 4 6))<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ 3 5 7))</span>
          </p>
          <p>requer que a regra de avaliação seja aplicada a quatro combinações diferentes. Podemos obter uma imagem deste processo porrepresentando a combinação na forma de umárvore, conforme mostrado na figura <a href="#fig-1.1">1.1</a>. Cada combinação é representada por uma nó comramos correspondentes ao operador e aos operandos da combinação dele decorrentes.nós terminais (isto é, nós sem ramificações originárias deles) representam operadores ou números. Visualizando a avaliação em termos de árvore, podemos imaginar que os valores dos operandos se infiltram para cima, começando pelos nós terminais e então se combinando em níveis cada vez mais altos. Em geral, veremos que a recursão é uma técnica muito poderosa para lidar com objetos hierárquicos, semelhantes a árvores. Na verdade, a forma "percolar valores para cima" da regra de avaliação é um exemplo de um tipo geral de processo conhecido como <em>acumulação de árvores</em>.</p>
          <div class="book-figure" id="fig-1.1">
               <img src="../image/ch1-Z-G-1.gif" alt="imagem do calculo do processo (* (+ 2 (* 4 6))(+ 3 5 7)) em forma de arvore">
               <span><strong>Figura 1.1:</strong> Representação em árvore, mostrando o valor de cada subcombinação.</span>
          </div> 
          <p>Em seguida, observe que a aplicação repetida do primeiro passo nos leva ao ponto em que precisamos avaliar, não combinações, mas expressões primitivas como numerais, operadores internos ou outros nomes. Cuidamos dos casos primitivos estipulando que</p>
          <ul>
               <li>os valores dos numerais são os números que eles nomeiam,</li>
               <li>os valores dos operadores integrados são as sequências de instruções da máquina que realizam as operações correspondentes e</li>
               <li>os valores de outros nomes são os objetos associados a esses nomes no ambiente.</li>
          </ul>
          <p>Podemos considerar a segunda regra como um caso especial da terceira, estipulando que símbolos como <em>+</em> e <em>*</em> também estão incluídos no ambiente global e estão associados às sequências de instruções de máquina que são seus "valores". O ponto-chave a ser observado é o papel doambiente na determinação do significado dos símbolos em expressões. Em uma linguagem interativa como Lisp, não faz sentido falar do valor de uma expressão como <em>(+ x 1)</em> sem especificar nenhuma informação sobre o ambiente que forneceria um significado para o símbolo  x (ou mesmo para o símbolo + ). Como veremos no capítulo 3, a noção geral do ambiente como provedor de um contexto no qual a avaliação ocorre desempenhará um papel importante em nossa compreensão da execução do programa.</p>  
          <p>Observe que a regra de avaliação dada acima não lida com definições. Por exemplo, avaliar <em>(define x 3)</em> não aplica define a dois argumentos, um dos quais é o valor do símbolo x e o outro é 3, já que o propósito de define é precisamente associar x a um valor. (Ou seja, <em>(define x 3)</em> não é uma combinação.)</p>  
          <p>Tais exceções à regra geral de avaliação são chamadas de formulários especiais . Define é o único exemplo de um formulário especial que vimos até agora, mas conheceremos outros em breve. Cada forma especial tem sua própria regra de avaliação. Os vários tipos de expressões (cada um com sua regra de avaliação associada) constituem osintaxe da linguagem de programação. Em comparação com a maioria das outras linguagens de programação, Lisp tem uma sintaxe muito simples; isto é, a regra de avaliação para expressões pode ser descrita por uma regra geral simples junto com regras especializadas para um pequeno número de formas especiais<sup><a href="">11</a></sup>.</p>
          <h2 id="1.1.4">1.1.4 Procedimentos compostos</h2>
          <p>Identificamos no Lisp alguns dos elementos que devem aparecer em qualquer linguagem de programação poderosa:</p>
          <ul>
               <li>Números e operações aritméticas são dados e procedimentos primitivos.</li>
               <li>O aninhamento de combinações fornece um meio de combinar operações.</li>
               <li>Definições que associam nomes a valores fornecem um meio limitado de abstração.</li>
          </ul>
          <p>Agora vamos aprender sobre <em>definições de procedimento</em>, uma técnica de abstração muito mais poderosa pela qual uma operação composta pode receber um nome e então ser referida como uma unidade.</p>  
          <p>Começamos examinando como expressar a ideia de "elevar ao quadrado". Podemos dizer: "Para elevar algo ao quadrado, multiplique-o por si mesmo". Isso é expresso em nossa linguagem como</p> 
          <p class="code">
               <span>(defina (quadrado x) (* x x))</span>
          </p>
          <p>Podemos entender isso da seguinte maneira:</p>  
          <p class="code">
               <span class="code-comment">;; Para elevar algo ao quadrado, multiplique-o por ele mesmo:</span>
               <span>(define (quadrado x) (* x x))</span>
          </p>
          <p>Temos aqui um <em>procedimento composto</em>, que recebeu o nome de <em>quadrado</em>. O procedimento representa a operação de multiplicar algo por si mesmo. A coisa a ser multiplicada recebe um nome local, <em>x</em>, que desempenha o mesmo papel que um pronome desempenha na linguagem natural. A avaliação da definição cria este procedimento composto e o associa ao nome <em>quadrado</em><sup><a href="">12</a></sup>.</p>  
          <p>A forma geral de uma definição de procedimento é</p>
          <p class="code">
               <span>(define (&lt;nome&gt; &lt;parâmetros formais&gt;) &lt;corpo&gt;)</span>
          </p> 
          <p class="three-points">Em tradução<span class="one">.</span><span class="two">.</span><span class="three">.</span></p> 
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
          <p></p>  
     </main>
</body>
</html>