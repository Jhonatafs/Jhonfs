<!DOCTYPE html>
<html lang="pt-br">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <title>Estrutura e Interpretação de Programas de Computador</title>
     <link rel="icon" type="image/png" href="/images/favicon.png" />
     <link rel="stylesheet" href="../css/normalize.css">
     <link rel="stylesheet" href="../css/book-page.css">
     <link rel="stylesheet" href="../css/navigation.css">
<script src="https://kit.fontawesome.com/0c2f8cb29c.js" crossorigin="anonymous"></script>
</head>
<body>
  <nav id="navbar-book">
    <ul>
         <!--Come back-->
         <li><a class="enabled" href="4.html"><i class="fa-solid fa-circle-left"></i></a></li>
         <!--Home-->
         <li><a class="enabled" href="/index.html"><i class="fa-solid fa-house"></i></a></li>
         <!--Cover-->
         <li><a class="enabled" href="../book.html"><i class="fa-solid fa-book"></i></a></li>
         <!--Content-->
         <li><a class="disabled"><i class="fa-solid fa-list-ul"></i></a></li>
         <!--Next-->
         <li><a class="enabled" href="6.html"><i class="fa-solid fa-circle-right"></i></i></a></li>
    </ul>
  </nav>
     <main>
<h1 class=chapter>Prefácio</h1>
<p>Educadores, generais, nutricionistas, psicólogos e pais programam. Exércitos, estudantes e algumas sociedades são programados. Um ataque a grandes problemas emprega uma sucessão de programas, a maioria dos quais surge no caminho. Esses programas estão cheios de problemas que parecem ser particulares ao problema em questão. Para apreciar a programação como uma atividade intelectual por si só, você deve recorrer à programação de computadores; você deve ler e escrever programas de computador &mdash; muitos deles. Não importa muito sobre o que os programas são ou quais aplicativos eles atendem. O que importa é quão bem eles funcionam e quão suavemente eles se encaixam com outros programas na criação de programas ainda maiores. O programador deve buscar tanto a perfeição da parte quanto a adequação da coleção. Neste livro, o uso de "programa" é focado na criação, execução e estudo de programas escritos em um dialeto de Lisp para execução em um computador digital. Usando Lisp, restringimos ou limitamos não o que podemos programar, mas apenas a notação para nossas descrições de programa.</p>
<p>Nosso tráfego com o assunto deste livro nos envolve com três focos de fenômenos: a mente humana, coleções de programas de computador e o computador. Cada programa de computador é um modelo, chocado na mente, de um processo real ou mental. Esses processos, decorrentes da experiência e do pensamento humanos, são enormes em número, intrincados em detalhes e, a qualquer momento, apenas parcialmente compreendidos. Eles são modelados para nossa satisfação permanente raramente por nossos programas de computador. Assim, embora nossos programas sejam coleções discretas cuidadosamente elaboradas de símbolos, mosaicos de funções interligadas, eles evoluem continuamente: nós os mudamos conforme nossa percepção do modelo se aprofunda, amplia, generaliza até que o modelo finalmente atinja um lugar metaestável dentro de outro modelo com o qual lutamos. A fonte da euforia associada à programação de computadores é o desdobramento contínuo dentro da mente e no computador de mecanismos expressos como programas e a explosão de percepção que eles geram. Se a arte interpreta nossos sonhos, o computador os executa sob o disfarce de programas!</p>
<p>Apesar de todo o seu poder, o computador é um capataz severo. Seus programas devem estar corretos, e o que desejamos dizer deve ser dito com precisão em todos os detalhes. Como em qualquer outra atividade simbólica, nos convencemos da verdade do programa por meio de argumentos. O próprio Lisp pode receber uma semântica (outro modelo, a propósito), e se a função de um programa pode ser especificada, digamos, no cálculo de predicados, os métodos de prova da lógica podem ser usados para fazer um argumento de correção aceitável. Infelizmente, à medida que os programas ficam grandes e complicados, como quase sempre acontece, a adequação, consistência e correção das próprias especificações tornam-se abertas à dúvida, de modo que argumentos formais completos de correção raramente acompanham programas grandes. Como programas grandes crescem a partir de pequenos, é crucial que desenvolvamos um arsenal de estruturas de programa padrão de cuja correção temos certeza &mdash; chamamos de expressões idiomáticas &mdash; e aprendamos a combiná-las em estruturas maiores usando técnicas organizacionais de valor comprovado. Essas técnicas são tratadas detalhadamente neste livro, e entendê-las é essencial para a participação no empreendimento prometeico chamado programação. Mais do que qualquer outra coisa, a descoberta e o domínio de técnicas organizacionais poderosas aceleram nossa capacidade de criar programas grandes e significativos. Por outro lado, como escrever programas grandes é muito desgastante, somos estimulados a inventar novos métodos de redução da massa de funções e detalhes a serem encaixados em programas grandes.</p>
<p>Ao contrário dos programas, os computadores devem obedecer às leis da física. Se eles desejam executar rapidamente &mdash; alguns nanossegundos por mudança de estado &mdash; eles devem transmitir elétrons apenas a pequenas distâncias (no máximo 1 <small><sup>1</sup>/<small>2</small></small> pés ). O calor gerado pelo enorme número de dispositivos tão concentrados no espaço tem que ser removido. Uma arte de engenharia requintada foi desenvolvida equilibrando entre multiplicidade de funções e densidade de dispositivos. Em qualquer caso, o hardware sempre opera em um nível mais primitivo do que aquele em que nos importamos em programar. Os processos que transformam nossos programas Lisp em programas de "máquina" são eles próprios modelos abstratos que programamos. Seu estudo e criação dão uma grande percepção sobre os programas organizacionais associados à programação de modelos arbitrários. Claro que o próprio computador pode ser modelado dessa forma. Pense nisso: o comportamento do menor elemento de comutação física é modelado pela mecânica quântica descrita por equações diferenciais cujo comportamento detalhado é capturado por aproximações numéricas representadas em programas de computador executados em computadores compostos de ... !</p>
<p>Não é meramente uma questão de conveniência tática identificar separadamente os três focos. Embora, como dizem, esteja tudo na cabeça, essa separação lógica induz uma aceleração do tráfego simbólico entre esses focos cuja riqueza, vitalidade e potencial são excedidos na experiência humana apenas pela evolução da própria vida. Na melhor das hipóteses, as relações entre os focos são metaestáveis. Os computadores nunca são grandes ou rápidos o suficiente. Cada avanço na tecnologia de hardware leva a empreendimentos de programação mais massivos, novos princípios organizacionais e um enriquecimento de modelos abstratos. Todo leitor deve se perguntar periodicamente "Para qual fim, para qual fim?" &mdash; mas não pergunte com muita frequência para não deixar passar a diversão da programação pela constipação da filosofia agridoce.</p>
<p>Entre os programas que escrevemos, alguns (mas nunca o suficiente) realizam uma função matemática precisa, como classificar ou encontrar o máximo de uma sequência de números, determinar primalidade ou encontrar a raiz quadrada. Chamamos esses programas de algoritmos, e muito se sabe sobre seu comportamento ótimo, particularmente com relação aos dois parâmetros importantes de tempo de execução e requisitos de armazenamento de dados. Um programador deve adquirir bons algoritmos e idiomas. Embora alguns programas resistam a especificações precisas, é responsabilidade do programador estimar e sempre tentar melhorar seu desempenho.</p>
<p>Lisp é um sobrevivente, tendo sido usado por cerca de um quarto de século. Entre as linguagens de programação ativas, apenas Fortran teve uma vida mais longa. Ambas as linguagens têm suportado as necessidades de programação de áreas importantes de aplicação, Fortran para computação científica e de engenharia e Lisp para inteligência artificial. Essas duas áreas continuam a ser importantes, e seus programadores são tão devotados a essas duas linguagens que Lisp e Fortran podem muito bem continuar em uso ativo por pelo menos mais um quarto de século.</p>
<p>Mudanças no Lisp. O dialeto Scheme usado neste texto evoluiu do Lisp original e difere deste último em várias maneiras importantes, incluindo escopo estático para vinculação de variáveis e permitindo que funções produzam funções como valores. Em sua estrutura semântica, o Scheme é tão parecido com o Algol 60 quanto com os primeiros Lisps. O Algol 60, que nunca mais será uma linguagem ativa, vive nos genes do Scheme e do Pascal. Seria difícil encontrar duas linguagens que sejam a moeda de comunicação de duas culturas mais diferentes do que aquelas reunidas em torno dessas duas linguagens. Pascal é para construir pirâmides &mdash; estruturas imponentes, de tirar o fôlego, estáticas, construídas por exércitos empurrando blocos pesados para o lugar. Lisp é para construir organismos &mdash; estruturas imponentes, de tirar o fôlego, dinâmicas, construídas por esquadrões que encaixam miríades flutuantes de organismos mais simples no lugar. Os princípios de organização usados são os mesmos em ambos os casos, exceto por uma diferença extraordinariamente importante: a funcionalidade exportável discricionária confiada ao programador Lisp individual é mais do que uma ordem de magnitude maior do que aquela encontrada nas empresas Pascal. Programas Lisp inflacionam bibliotecas com funções cuja utilidade transcende a aplicação que as produziu. A lista, a estrutura de dados nativa do Lisp, é amplamente responsável por tal crescimento de utilidade. A estrutura simples e a aplicabilidade natural das listas são refletidas em funções que são surpreendentemente não idiossincráticas. Em Pascal, a abundância de estruturas de dados declaráveis induz uma especialização dentro de funções que inibe e penaliza a cooperação casual. É melhor ter 100 funções operando em uma estrutura de dados do que ter 10 funções operando em 10 estruturas de dados. Como resultado, a pirâmide deve permanecer inalterada por um milênio; o organismo deve evoluir ou perecer.</p>
<p>Para ilustrar essa diferença, compare o tratamento do material e dos exercícios dentro deste livro com o de qualquer texto de primeiro curso usando Pascal. Não trabalhe sob a ilusão de que este é um texto digerível apenas no MIT, peculiar à raça encontrada lá. É precisamente o que um livro sério sobre programação Lisp deve ser, não importa quem seja o aluno ou onde ele seja usado.</p>
<p>Note que este é um texto sobre programação, diferente da maioria dos livros de Lisp, que são usados como preparação para o trabalho em inteligência artificial. Afinal, as preocupações críticas de programação da engenharia de software e inteligência artificial tendem a se unir à medida que os sistemas sob investigação se tornam maiores. Isso explica por que há tanto interesse crescente em Lisp fora da inteligência artificial.</p>
<p>Como seria de se esperar de seus objetivos, a pesquisa em inteligência artificial gera muitos problemas significativos de programação. Em outras culturas de programação, essa onda de problemas gera novas linguagens. De fato, em qualquer tarefa de programação muito grande, um princípio de organização útil é controlar e isolar o tráfego dentro dos módulos de tarefa por meio da invenção da linguagem. Essas linguagens tendem a se tornar menos primitivas à medida que nos aproximamos dos limites do sistema onde nós, humanos, interagimos com mais frequência. Como resultado, esses sistemas contêm funções complexas de processamento de linguagem replicadas muitas vezes. O Lisp tem uma sintaxe e semântica tão simples que a análise sintática pode ser tratada como uma tarefa elementar. Assim, a tecnologia de análise sintática quase não desempenha nenhum papel em programas Lisp, e a construção de processadores de linguagem raramente é um impedimento para a taxa de crescimento e mudança de grandes sistemas Lisp. Finalmente, é essa simplicidade de sintaxe e semântica que é responsável pelo fardo e liberdade suportados por todos os programadores Lisp. Nenhum programa Lisp de qualquer tamanho além de algumas linhas pode ser escrito sem ser saturado com funções discricionárias. Invente e ajuste; tenha ajustes e reinvente! Brindamos ao programador Lisp que escreve seus pensamentos entre parênteses.</p>
<p>Alan J. Perlis<br>Nova Haven, Connecticut</p>
</main>

</body>
</html>
