<!DOCTYPE html>
<html lang="pt-BR">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="X-UA-Compatible" content="IE=Edge">
     <meta name="application-name" content="JhonFs">
     <meta name="description" content="Blog">
     <link rel="icon" type="image/png" href="/img/fovicon.svg" />
     <title>SICP | JhonFs</title>
     <!--CSS-->
     <link rel="stylesheet" href="/css/normalize.css">
     <link rel="stylesheet" href="/css/book.css">
     <link rel="stylesheet" href="/css/style.css">
     <link rel="stylesheet" href="/css/icons.css">
     <link rel="stylesheet" href="/css/dracula.css">
     <!--SCRIPT-->
     <script src="/js/light.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
     <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
     <script>hljs.highlightAll();</script>
     </head>
<body>
     <div id="top"></div>
     <!--Floating Buttons-->
     <div class="floating-button floating-top-position">
          <button class="floating-button-formatting" id="button-light" onclick="lightStatus()"><span class="floating-button-icon icon_theme"></span></button>
     </div>
     <button id="backToTop"><span class="icon_top"></span></button>
     <!--Navegation book-->
     <div id="book-nav">
          <a href="/arquive/sicp-pt-br/30.html" id="back-page"><span class="icon_back icon"></span></a>
          <a href="/arquive/sicp-pt-br/4.html" id="content-page"><span class="icon_content icon"></span></a>
          <a href="/index.html" id="exit-page"><span class="icon_exit icon"></span></a>
          <a href="/arquive/sicp-pt-br.html" id="cover-page"><span class="icon_cover icon"></span></a>
          <a href="/arquive/sicp-pt-br/32.html" id="next-page"><span class="icon_next icon"></span></a>
     </div>
     <!--Content-->
     <article>
          <span id="chapter">Capítulo 2: Construindo Abstrações com Dados</span>
          <h1>Capítulo 2</h1>
          <span class="quote">Chegamos agora ao passo decisivo da abstração matemática: esquecemos para que os símbolos servem... [O matemático] não precisa ficar ocioso; há muitas operações que ele pode realizar com esses símbolos, sem nunca ter que olhar para as coisas que eles representam.<br><br>&mdash; <span lang="en">Hermann Weyl, <em>The Mathematical Way of Thinking</em></span></span>
               <p class="word-cappilar">Concentramo-nos no Capítulo 1 nos processos computacionais e no papel dos procedimentos no design de programas. Vimos como usar dados primitivos (números) e operações primitivas (operações aritméticas), como combinar procedimentos para formar procedimentos compostos através de composição, condicionais e o uso de parâmetros, e como abstrair procedimentos utilizando <span class="code">define</span>. Vimos que um procedimento pode ser considerado como um padrão para a evolução local de um processo, e classificamos, raciocinamos e realizamos análises algorítmicas simples de alguns padrões comuns para processos incorporados em procedimentos. Também vimos que procedimentos de ordem superior aumentam o poder da linguagem, permitindo-nos manipular e raciocinar em termos de métodos gerais de computação. Isso é muito da essência da programação.</p>
               <p>Neste capítulo, vamos analisar dados mais complexos. Todos os procedimentos no Capítulo 1 operam sobre dados numéricos simples, que não são suficientes para muitos problemas que desejamos abordar usando computação. Programas geralmente são projetados para modelar fenômenos complexos, necessitando frequentemente de objetos computacionais que tenham várias partes para modelar aspectos do mundo real. Assim, enquanto nosso foco no Capítulo 1 foi construir abstrações combinando procedimentos para formar procedimentos compostos, neste capítulo nos voltamos para outro aspecto fundamental de qualquer linguagem de programação: os meios que ela fornece para construir abstrações combinando objetos de dados para formar <em>dados compostos</em>.</p>
               <p>Por que queremos dados compostos em uma linguagem de programação? Pelas mesmas razões que queremos procedimentos compostos: para elevar o nível conceitual no qual podemos projetar nossos programas, para aumentar a modularidade de nossos designs e para aprimorar o poder expressivo de nossa linguagem. Assim como a capacidade de definir procedimentos nos permite lidar com processos em um nível conceitual mais alto do que o das operações primitivas da linguagem, a capacidade de construir objetos de dados compostos nos permite lidar com dados em um nível conceitual mais alto do que o dos objetos de dados primitivos da linguagem.</p>
               <p>Considere a tarefa de projetar um sistema para realizar operações aritméticas com números racionais. Poderíamos imaginar uma operação chamada <span class="code">add-rat</span>, que recebe dois números racionais e produz sua soma. Em termos de dados simples, um número racional pode ser considerado como dois inteiros: um numerador e um denominador. Assim, poderíamos projetar um programa no qual cada número racional seria representado por dois inteiros (um numerador e um denominador) e onde <span class="code">add-rat</span> seria implementado por dois procedimentos (um produzindo o numerador da soma e outro produzindo o denominador). Mas isso seria inconveniente, pois precisaríamos rastrear explicitamente quais numeradores correspondem a quais denominadores. Em um sistema destinado a realizar muitas operações com muitos números racionais, tais detalhes de contabilidade atrapalhariam substancialmente os programas, sem mencionar o que fariam com nossas mentes. Seria muito melhor se pudéssemos "unir" um numerador e um denominador para formar um par -- um <em>objeto de dados composto</em> -- que nossos programas poderiam manipular de maneira consistente com a consideração de um número racional como uma única unidade conceitual.</p>
               <p>O uso de dados compostos também nos permite aumentar a modularidade de nossos programas. Se pudermos manipular números racionais diretamente como objetos em si mesmos, podemos separar a parte do programa que lida com números racionais per se dos detalhes de como os números racionais podem ser representados como pares de inteiros. A técnica geral de isolar as partes de um programa que tratam de como os objetos de dados são representados das partes que tratam de como os objetos de dados são usados é uma metodologia de design poderosa chamada <em>abstração de dados</em>. Veremos como a abstração de dados torna os programas muito mais fáceis de projetar, manter e modificar.</p>
               <p>O uso de dados compostos leva a um aumento real no poder expressivo de nossa linguagem de programação. Considere a ideia de formar uma "combinação linear" <em>ax</em> + <em>by</em>. Poderíamos querer escrever um procedimento que aceite <em>a</em>, <em>b</em>, <em>x</em> e <em>y</em> como argumentos e retorne o valor de <em>ax</em> + <em>by</em>. Isso não apresenta dificuldade se os argumentos forem números, porque podemos definir facilmente o procedimento:</p>
               <pre><code class="language-scheme">(define (linear-combination a b x y)
     (+ (* a x) (* b y)))</code></pre>
               <p>Mas suponha que não estejamos preocupados apenas com números. Suponha que queiramos expressar, em termos procedurais, a ideia de que podemos formar combinações lineares sempre que a adição e a multiplicação estiverem definidas -- para números racionais, números complexos, polinômios ou qualquer outra coisa. Poderíamos expressar isso como um procedimento da forma:</p>
               <pre><code class="language-scheme">(define (linear-combination a b x y)
     (add (mul a x) (mul b y)))</code></pre>
               <p>Aqui, <span class="code">add</span> e <span class="code">mul</span> não são os procedimentos primitivos <span class="code">+</span> e <span class="code">*</span>, mas sim estruturas mais complexas que executarão as operações apropriadas para qualquer tipo de dado passado como argumentos <span class="code">a</span>, <span class="code">b</span>, <span class="code">x</span> e <span class="code">y</span>. O ponto-chave é que a única coisa que <span class="code">linear-combination</span> precisa saber sobre <span class="code">a</span>, <span class="code">b</span>, <span class="code">x</span> e <span class="code">y</span> é que os procedimentos <span class="code">add</span> e <span class="code">mul</span> realizarão as manipulações adequadas. Do ponto de vista do procedimento <span class="code">linear-combination</span>, é irrelevante o que <span class="code">a</span>, <span class="code">b</span>, <span class="code">x</span> e <span class="code">y</span> são, e ainda mais irrelevante como eles podem estar representados em termos de dados mais primitivos.<sup id="note-1"></sup> Este exemplo também demonstra por que é importante que nossa linguagem de programação permita a manipulação direta de objetos compostos: sem isso, não haveria como um procedimento como <span class="code">linear-combination</span> passar seus argumentos para <span class="code">add</span> e <span class="code">mul</span> sem conhecer sua estrutura detalhada.</p>
               <p>Começamos este capítulo implementando o sistema de aritmética com números racionais mencionado acima. Isso formará o pano de fundo para nossa discussão sobre dados compostos e abstração de dados. Assim como ocorre com procedimentos compostos, a principal questão a ser abordada é a abstração como técnica para lidar com a complexidade, e veremos como a abstração de dados nos permite erguer barreiras de abstração adequadas entre diferentes partes de um programa.</p>
               <p>Veremos que a chave para formar dados compostos é que uma linguagem de programação deve fornecer algum tipo de "cola" para que objetos de dados possam ser combinados para formar objetos de dados mais complexos. Existem muitos tipos possíveis de cola. De fato, descobriremos como formar dados compostos usando nenhuma operação "de dados" especial, apenas procedimentos. Isso borrará ainda mais a distinção entre "procedimento" e "dados", que já estava se tornando tênue no final do Capítulo 1. Também exploraremos algumas técnicas convencionais para representar sequências e árvores. Uma ideia-chave ao lidar com dados compostos é a noção de <em>closure</em> -- que a cola que usamos para combinar objetos de dados deve permitir que combinemos não apenas objetos de dados primitivos, mas também objetos de dados compostos. Outra ideia-chave é que objetos de dados compostos podem servir como <em>interfaces convencionais</em> para combinar módulos de programa de forma intercambiável. Ilustraremos algumas dessas ideias apresentando uma linguagem gráfica simples que explora <em>closure</em>.</p>
               <p>Em seguida, aumentaremos o poder representacional de nossa linguagem introduzindo <em>expressões simbólicas</em> -- dados cujas partes elementares podem ser símbolos arbitrários em vez de apenas números. Exploraremos várias alternativas para representar conjuntos de objetos. Descobriremos que, assim como uma dada função numérica pode ser calculada por muitos processos computacionais diferentes, há muitas maneiras pelas quais uma dada estrutura de dados pode ser representada em termos de objetos mais simples, e a escolha da representação pode ter um impacto significativo nos requisitos de tempo e espaço dos processos que manipulam os dados. Investigaremos essas ideias no contexto de diferenciação simbólica, representação de conjuntos e codificação de informações.</p>
               <p>Por fim, abordaremos o problema de trabalhar com dados que podem ser representados de maneiras diferentes por diferentes partes de um programa. Isso leva à necessidade de implementar <em>operações genéricas</em>, que devem lidar com muitos tipos diferentes de dados. Manter a modularidade na presença de operações genéricas requer barreiras de abstração mais poderosas do que podem ser erguidas apenas com abstração de dados simples. Em particular, introduzimos a <em>programação dirigida a dados</em> como uma técnica que permite que representações individuais de dados sejam projetadas isoladamente e, em seguida, combinadas <em>aditivamente</em> (ou seja, sem modificação). Para ilustrar o poder dessa abordagem ao design de sistemas, encerramos o capítulo aplicando o que aprendemos à implementação de um pacote para realizar aritmética simbólica em polinômios, nos quais os coeficientes dos polinômios podem ser inteiros, números racionais, números complexos e até mesmo outros polinômios.</p>
          <hr id="footnote-line">
          <section id="footnotes">
               <p id="footnote-1"><sup><a href="#note-1">1</a></sup> A habilidade de manipular diretamente procedimentos também aumenta o poder expressivo de uma linguagem de programação.</p>
          </section>
     </article>      
     <!--Script Scroll Top-->     
     <script src="/js/buttonToTop.js"></script>
</body>
</html>