<!DOCTYPE html>
<html lang="pt-BR">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta http-equiv="X-UA-Compatible" content="IE=Edge">
     <meta name="application-name" content="JhonFs">
     <meta name="description" content="Blog">
     <link rel="icon" type="image/png" href="/img/fovicon.svg" />
     <title>SICP | JhonFs</title>
     <!--CSS-->
     <link rel="stylesheet" href="/css/normalize.css">
     <link rel="stylesheet" href="/css/book.css">
     <link rel="stylesheet" href="/css/style.css">
     <link rel="stylesheet" href="/css/icons.css">
     <!--SCRIPT-->
     <script src="/js/light.js"></script>
     </head>
<body>
     <div id="top"></div>
     <!--Floating Buttons-->
     <div class="floating-button floating-top-position">
          <button class="floating-button-formatting" id="button-light" onclick="lightStatus()"><span class="floating-button-icon icon_theme"></span></button>
     </div>
     <button id="backToTop"><span class="icon_top"></span></button>
     <!--Navegation book-->
     <div id="book-nav">
          <a href="/arquive/sicp-pt-br/8.html" id="back-page"><span class="icon_back icon"></span></a>
          <a href="/arquive/sicp-pt-br/4.html" id="content-page"><span class="icon_content icon"></span></a>
          <a href="/index.html" id="exit-page"><span class="icon_exit icon"></span></a>
          <a href="/arquive/sicp-pt-br.html" id="cover-page"><span class="icon_cover icon"></span></a>
          <a href="/arquive/sicp-pt-br/10.html" id="next-page"><span class="icon_next icon"></span></a>
     </div>
     <!--Content-->
     <article>
          <span id="chapter">Capítulo 1</span>
          <h1>Construindo abstrações com procedimentos</h1>
          <span></span>
          <p class="quote">Os atos da mente, nos quais ela exerce seu poder sobre ideias simples, são principalmente estes três: 1. Combinar várias ideias simples em uma composta, e assim todas as ideias complexas são formadas. 2. O segundo é reunir duas ideias, sejam elas simples ou complexas, e colocá-las lado a lado para observá-las simultaneamente, sem uni-las em uma só, por meio do que se obtém todas as ideias de relações. 3. O terceiro é separá-las de todas as outras ideias que as acompanham em sua existência real: isso é chamado de abstração, e assim são formadas todas as suas ideias gerais. <br>&ndash; John Locke, Um ensaio sobre o entendimento humano (1690)</p>
          <p class="word-cappilar">Estamos prestes a estudar a ideia de um processo computacional. Processos computacionais são seres abstratos que habitam os computadores. À medida que evoluem, os processos manipulam outras coisas abstratas chamadas dados. A evolução de um processo é dirigida por um padrão de regras chamado programa. As pessoas criam programas para direcionar processos. Em efeito, conjuramos os espíritos do computador com nossos feitiços.</p>
          <p>Um processo computacional é, de fato, muito parecido com a ideia de um espírito de um feiticeiro. Ele não pode ser visto nem tocado. Não é composto de matéria de forma alguma. No entanto, é muito real. Ele pode realizar trabalho intelectual. Pode responder a perguntas. Pode afetar o mundo distribuindo dinheiro em um banco ou controlando um braço robótico em uma fábrica. Os programas que usamos para conjurar processos são como feitiços de um feiticeiro. Eles são cuidadosamente compostos de expressões simbólicas em linguagens de programação arcanas e esotéricas que prescrevem as tarefas que queremos que nossos processos realizem.</p>
          <p>Um processo computacional, em um computador que funciona corretamente, executa programas de maneira precisa e exata. Assim, como o aprendiz de feiticeiro, programadores novatos devem aprender a entender e a antecipar as consequências de suas conjurações. Mesmo pequenos erros (geralmente chamados de bugs ou falhas) em programas podem ter consequências complexas e inesperadas.</p>
          <p>Felizmente, aprender a programar é consideravelmente menos perigoso do que aprender feitiçaria, porque os espíritos com os quais lidamos estão convenientemente contidos de maneira segura. No entanto, a programação no mundo real exige cuidado, expertise e sabedoria. Um pequeno erro em um programa de design assistido por computador, por exemplo, pode levar ao colapso catastrófico de um avião ou de uma represa ou à autodestruição de um robô industrial.</p>
          <p>Engenheiros de software experientes têm a habilidade de organizar programas de modo que possam estar razoavelmente seguros de que os processos resultantes executarão as tarefas pretendidas. Eles conseguem visualizar o comportamento de seus sistemas com antecedência. Sabem como estruturar programas para que problemas inesperados não levem a consequências catastróficas, e, quando surgem problemas, conseguem depurar seus programas. Sistemas computacionais bem projetados, como automóveis ou reatores nucleares bem projetados, são concebidos de forma modular, para que as partes possam ser construídas, substituídas e depuradas separadamente.</p>
          <h2>Programando em Lisp</h2>
          <p>Precisamos de uma linguagem adequada para descrever processos, e utilizaremos para esse fim a linguagem de programação Lisp &mdash; caso prefira pode estudar pela versão em JavaScript <a class="icon_linkexternal" href="https://sourceacademy.org/sicpjs/foreword02" target="_blank"></a>. Da mesma forma que nossos pensamentos cotidianos geralmente são expressos em nossa linguagem natural (como Inglês, Francês ou Japonês), e as descrições de fenômenos quantitativos são expressas com notações matemáticas, nossos pensamentos procedurais serão expressos em Lisp. Lisp foi inventada no final da década de 1950 como um formalismo para raciocinar sobre o uso de certos tipos de expressões lógicas, chamadas equações recursivas, como um modelo de computação. A linguagem foi concebida por John McCarthy e baseia-se em seu artigo "Funções Recursivas de Expressões Simbólicas e Sua Computação por Máquina" (McCarthy, 1960).</p>
          <p>Apesar de sua origem como um formalismo matemático, Lisp é uma linguagem de programação prática. Um interpretador de Lisp é uma máquina que executa processos descritos na linguagem Lisp. <sup id="note-1"></sup>O primeiro interpretador de Lisp foi implementado por McCarthy com a ajuda de colegas e alunos do Grupo de Inteligência Artificial do Laboratório de Pesquisa em Eletrônica do MIT e do Centro de Computação do MIT.<sup><a href="#footnote-1" id="note-1">1</a></sup> Lisp, cujo nome é um acrônimo para LISt Processing (Processamento de Listas), foi projetado para fornecer capacidades de manipulação de símbolos para resolver problemas de programação, como a diferenciação e integração simbólica de expressões algébricas. Para esse fim, incluía novos objetos de dados conhecidos como átomos e listas, que o distinguiam marcadamente de todas as outras linguagens da época.</p>
          <p>Lisp não foi o produto de um esforço de design concertado. Em vez disso, evoluiu de maneira informal e experimental em resposta às necessidades dos usuários e às considerações pragmáticas de implementação. A evolução informal de Lisp continuou ao longo dos anos, e a comunidade de usuários de Lisp tradicionalmente resistiu a tentativas de promulgar qualquer definição "oficial" da linguagem. Essa evolução, juntamente com a flexibilidade e elegância da concepção inicial, permitiu que Lisp, que é a segunda linguagem mais antiga em uso generalizado hoje (somente o Fortran é mais antigo), se adaptasse continuamente para englobar as ideias mais modernas sobre design de programas. Assim, Lisp é agora uma família de dialetos que, embora compartilhem a maioria das características originais, podem diferir significativamente entre si. <sup id="note-2"></sup>O dialeto de Lisp utilizado neste livro é chamado Scheme.<sup><a href="#footnote-2" id="note-2">2</a></sup></p>
          <p>Devido ao seu caráter experimental e à ênfase na manipulação de símbolos, Lisp era inicialmente muito ineficiente para cálculos numéricos, pelo menos em comparação com Fortran. Ao longo dos anos, no entanto, compiladores de Lisp foram desenvolvidos para traduzir programas em código de máquina que podem realizar cálculos numéricos de maneira razoavelmente eficiente. E, para aplicações especiais, Lisp tem sido usado com grande eficácia. <sup id="note-3"></sup>Embora Lisp ainda não tenha superado sua antiga reputação de ser irremediavelmente ineficiente, hoje é usada em muitas aplicações onde a eficiência não é a preocupação central.<sup><a href="#footnote-3">3</a></sup> Por exemplo, Lisp tornou-se a linguagem preferida para linguagens de shell de sistemas operacionais e para linguagens de extensão de editores e sistemas de design auxiliado por computador.</p>
          <p>Se Lisp não é uma linguagem predominante, por que a estamos usando como base para nossa discussão sobre programação? Porque a linguagem possui características únicas que a tornam um excelente meio para estudar importantes estruturas de programação e de dados e para relacioná-las às características linguísticas que as sustentam. A mais significativa dessas características é o fato de que as descrições de processos em Lisp, chamadas de procedimentos, podem ser representadas e manipuladas como dados em Lisp. A importância disso reside no fato de que existem poderosas técnicas de design de programas que dependem da capacidade de borrar a distinção tradicional entre dados "passivos" e processos "ativos". Como descobriremos, a flexibilidade do Lisp em lidar com procedimentos como dados o torna uma das linguagens mais convenientes para explorar essas técnicas. A capacidade de representar procedimentos como dados também faz do Lisp uma excelente linguagem para escrever programas que precisam manipular outros programas como dados, como os interpretadores e compiladores que suportam linguagens de computador. Além dessas considerações, programar em Lisp é extremamente divertido.</p>
          <hr id="footnote-line">
          <section id="footnotes">
               <p id="footnote-1"><sup><a href="#note-1">1</a></sup> O <em>Lisp 1 Programmer's Manual</em> foi publicado      em 1960, e o Lisp 1.5 Programmer's Manual (McCarthy 1965) foi publicado em 1962. A história inicial      do Lisp é descrita em McCarthy 1978.</p> <p id="footnote-2"><sup><a href="#note-2">2</a></sup> Os dois dialetos em que a maioria dos principais      programas Lisp da década de 1970 foram escritos são o MacLisp (Moon 1978; Pitman 1983), desenvolvido      no MIT Project MAC, e o Interlisp (Teitelman 1974), desenvolvido na Bolt Beranek and Newman Inc. e      no Xerox Palo Alto Research Center. O <em>Portable Standard Lisp</em> (Hearn 1969; Griss 1981) foi      um dialeto Lisp projetado para ser facilmente portável entre diferentes máquinas. O MacLisp gerou      vários subdialetos, como o Franz Lisp, que foi desenvolvido na Universidade da Califórnia em      Berkeley, e o Zetalisp (Moon 1981), que foi baseado em um processador de propósito especial      projetado no Laboratório de Inteligência Artificial do MIT para executar Lisp de maneira muito      eficiente. O dialeto Lisp usado neste livro, chamado Scheme (Steele 1975), foi inventado em 1975 por      Guy Lewis Steele Jr. e Gerald Jay Sussman, do Laboratório de Inteligência Artificial do MIT, e mais      tarde reimplementado para uso instrucional no MIT. Scheme tornou-se um padrão IEEE em 1990 (IEEE      1990). O dialeto Common Lisp (Steele 1982, Steele 1990) foi desenvolvido pela comunidade Lisp para      combinar características dos primeiros dialetos Lisp, a fim de criar um padrão industrial para Lisp.      O Common Lisp tornou-se um padrão ANSI em 1994 (ANSI 1994).</p> <p id="footnote-3"><sup><a href="#note-3">3</a></sup> Uma dessas aplicações especiais foi um avanço      computacional de importância científica — uma integração do movimento do Sistema Solar que ampliou      os resultados anteriores em quase duas ordens de magnitude e demonstrou que a dinâmica do Sistema      Solar é caótica. Esta computação foi viabilizada por novos algoritmos de integração, um compilador      de propósito especial e um computador de propósito especial, todos implementados com a ajuda de      ferramentas de software escritas em Lisp (Abelson et al. 1992; Sussman e Wisdom 1992).</p>
          </section>
     </article>
     <script src="/js/buttonToTop.js"></script>
</body>

</html>