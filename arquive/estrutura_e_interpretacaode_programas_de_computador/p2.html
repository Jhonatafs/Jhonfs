<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta name="application-name" content="JhonFs" />
    <meta name="description" content="Blog" />
    <link rel="icon" type="image/png" href="/img/fovicon.svg" />
    <title>JhonFs</title>
    <!--CSS-->
    <link rel="stylesheet" href="/css/normalize.css" />
    <link rel="stylesheet" href="/css/global.css" />
    <link rel="stylesheet" href="/css/article.css" />
    <link rel="stylesheet" href="/css/icons.css" />
    <link rel="stylesheet" href="/css/dracula.css" />
    <!--SCRIPT-->
    <script src="/js/light.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/scheme.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
  </head>
  <body>
    <div id="top"></div>

    <div class="floating-button floating-top-position">
      <!--<a
        class="floating-button-formatting floating-button-icon icon_translate"
        href="/index-en.html"
      ></a>-->
      <a
        class="floating-button-formatting floating-button-icon icon_home"
        href="/index.html"
        style="font-size: 20px"
      ></a>
      <button
        class="floating-button-formatting"
        id="button-light"
        onclick="lightStatus()"
      >
        <span class="floating-button-icon icon_theme"></span>
      </button>
    </div>
    <button id="backToTop"><span class="icon_top"></span></button>

    <div id="nav-page">
      <a
        href="/arquive/estrutura_e_interpretacaode_programas_de_computador/p1.html"
        >Voltar</a
      >
      <a href="content.html">Conteudo</a>
      <a href="#">Proximo</a>
    </div>

    <article id="main">
      <h1 id="remove-margin">
        Estrutura e Interpretação de Programas de Computador
      </h1>
      <span id="subtitle"
        >Notas do livro
        <em lang="en"
          >Structure and Interpretation of Computer Programs (SICP)</em
        >, e do curso <em>CS 61A </em> de
        <span lang="en">Brian Harvey’s Berkeley</span></span
      >

      <span id="nav-line"
        ><a href="/index.html">Início</a> &gt;
        <a href="/arquive/notasdeestudo.html">Notas de Estudo</a> &gt;
        <a href="">...</a> &gt;
        <strong>Construção e abstração com procedimentos</strong></span
      >

      <h2 id="t1">Construção e abstração com procedimentos</h2>
      <p>
        Segundo Locke, a mente humana realiza três operações básicas para
        construir o conhecimento: a combinação, a definição e a abstração. Ao
        combinar ideias simples, a mente cria novas e complexas. Ao definir e
        relacionar ideias, ela estabelece conexões entre elas. E ao abstrair
        características específicas, ela forma conceitos gerais. Esses três atos
        mentais trabalham em conjunto para moldar nossa compreensão do mundo.
        Isso é a base para entender a computação e suas linguagens.
      </p>
      <h3>Procedimento e Processo</h3>
      <p>
        Tendo estabelecido a natureza da Ciência da Computação, vamos nos
        aprofundar em conceitos mais específicos, começando pelos dados,
        processos e procedimentos.
      </p>
      <ul>
        <li>
          Os <strong>dados</strong> são as informações que manipulamos, como
          números ou textos.
        </li>
        <li>
          O <strong>procedimento</strong> é a receita, a sequência de passos
          para processar esses dados. Ao executar um procedimento, criamos um
          processo.
        </li>
        <li>
          <strong>Processo</strong>, é a ação concreta de seguir a receita,
          transformando os dados em um resultado.
        </li>
      </ul>
      <p>
        Na programação, as "ideias simples" de Locke se manifestam tembém como
        dados e procedimentos.
      </p>
      <p>
        Para podermos avançar em abstrações com procedimentos é preciso avançar
        em paralelo com programação, e para isso vamos aprender a linguagem
        Scheme, um dialeto do LISP, e para isso recomendo a IDE Dr.Racket com o
        pacote sicp para campatibilidade total com os códigos do livro
        <em>SICP</em>.
      </p>
      <p>Para aprender qualquer linguagem de programação é preciso entender:</p>
      <ul>
        <li>
          As <strong>expressões primitivas</strong> são os componentes básicos
          da linguagem, como números, strings e booleanos;
        </li>
        <li>
          Os <strong>meios de combinação</strong> são os mecanismos que combinam
          elementos para formar expressões mais complexas;
        </li>
        <li>
          E os <strong>meios de abstração</strong> os quais permitem dar nomes e
          manipular elementos compostos.
        </li>
      </ul>
      <p>
        Uma <strong>expressão</strong> é o meio usado para expressar algo para a
        maquina. Antes de mostrar os exemplos é importante e util entender o que
        é comentários em uma linguagem de programação. Os comentários são usados
        para anotar detalhes importantes no código. Em Scheme, comentários
        começam com <span class="code">;;</span> e continuam até o final da
        linha, e não são interpretados pela maquina.
      </p>
      <pre><code class="language-scheme">
;; Dados simples
10      ;; Retorna 10
"Nome"  ;; Retorna "Nome"

;; Nomeando Dados (Variaveis)
;; (define &lt;nome&gt;&lt;dado&gt; )
(define idade 20)      ;; Numero
(define nome "Fulano") ;; String
(define amo-estudar #t) ;; Booleano
                       ;;(#t Verdade, #f Falso)

;; Chamando as Variaveis
idade       ;; Retorna 20
nome        ;; Retorna "Fulano"
amo-estudar ;; Retorna #t
     </code></pre>
      <p>
        São pelos <strong>meios de combinação</strong> que criamos procedimentos
        mais robustos, permitindo expressar conceitos mais complexos, vejamos:
      </p>
      <pre><code class="language-scheme">
;; Números inteiros
(define a 10)
(define b 5)

;; Operações aritméticas
(+ a b)  ;; Soma: 15
(- a b)  ;; Subtração: 5
(* a b)  ;; Multiplicação: 50
(/ a b)  ;; Divisão: 2

(* 10 (/ (- (+ a b) (- a b))  2));; Retorna 50

;; String
(define nome "Fulano")
(define sobrenome "de Tal")

;; Concatenando strings
(string-append nome " " sobrenome)  ;; Retorna "Fulano de Tal"

;; Expressões lógicas (Booleano)
;; Operador 'and'
(and #t #t)  ;; Retorna #t
(and #t #f)  ;; Retorna #f
(and #f #t)  ;; Retorna #f
(and #f #f)  ;; Retorna #f

;; Operador 'or'
(or #t #t)  ;; Retorna #t
(or #t #f)  ;; Retorna #t
(or #f #t)  ;; Retorna #t
(or #f #f)  ;; Retorna #f

;; Operador 'not'
(not #t)  ;; Retorna #f
(not #f)  ;; Retorna #t

;; Combinando Expressões Lógicas
(and (or #t #f) (not #f))  ;; Retorna #t
      </code></pre>
      <p>
        Tendo dominado o que são expressões, expressões primitivas, meios de
        combinação, agora é manipular tudo isso como se fosse um unico elemento,
        um objeto abstrato. E para isso usamos funções.
      </p>
      <p>
        Funções é uma entidade a qual recebe argumentos e retorna um valor,
        vejamos:
      </p>
      <pre><code class="language-scheme">
;; A estrutura da função é:
;; (define (nome-da-função &lt;parâmetro&gt;)
;;    corpo)

;; Definindo uma função simples
(define (quadrado x)
  (* x x))

;; Usando a função
(quadrado 5)  ;; Retorna 25
    </code></pre>
      <p>
        Criamos a função <span class="code">quadrado</span> a qual recebe o
        parametro <span class="code">x</span> e usamos do nosso conhecimento de
        meios de combinação para calcular o quadrado de um número qualquer
        representado por <span class="code">x</span>.
      </p>
      <p>
        Outra tipo de função é a anônima, ou seja, uma função que não tem nome.
        Em Scheme, funções anônimas ou lambda são criadas usando a palavra-chave
        lambda. Elas são úteis para criar funções temporárias ou para passar
        funções como argumentos para outras funções:
      </p>
      <pre><code class="linguage-scheme">
;; Definindo uma função anônima. Estrutura:
;; ((lambda (&lt;parâmetro&gt;) (&lt;corpo&gt;)) &lt;variavel&gt;)
((lambda (x) (* x x)) 3)  ;; Retorna 9

;; Usando lambda em uma função definida
(define quadrado (lambda (x) (* x x)))
(quadrado 3)  ;; Retorna 9
    </code></pre>
      <h3>Modelo de Substituição para Aplicação de Procedimentos</h3>

      <p>
        O <strong>modelo de substituição</strong> é uma técnica que descreve a
        execução de funções como um processo de substituição, onde as chamadas
        de procedimento são substituídas por seus corpos, com os argumentos
        apropriados.
      </p>
      <pre><code class="language">
(define (square x)
    (* x x)) ;; Corpo
      
(square 3) ;; Chamada
      </code></pre>

      <p>O modelo de substituição segue três passos principais:</p>
      <ol>
        <li>
          <strong>Expansão (Substituição):</strong> A chamada do procedimento é
          substituída pelo seu corpo, trocando os parâmetros formais pelos
          valores dos argumentos.
        </li>
        <pre><code class="language-scheme">
;; Isso (square 3) é substituido por:
(* 3 3)
        </code></pre>
        <li>
          <strong>Redução (Avaliação):</strong> A expressão resultante é
          avaliada até que se torne um valor.
        </li>
        <pre><code class="language-scheme">
;; Isso (* 3 3) retorna:
9
        </code></pre>
        <li>
          <strong>Encerramento:</strong> Quando o resultado final é um valor
          atômico (exemplo: um número), o processo termina.
        </li>
      </ol>

      <h4>Exemplo: Aplicação Aninhada</h4>

      <pre><code class="language-scheme">
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
      </code></pre>

      <p>Substituímos a chamada do procedimento:</p>

      <pre><code class="language-scheme">
(sum-of-squares 3 4)        ;; Chamada
→ (+ (square 3) (square 4)) ;; Expansão
→ (+ (* 3 3) (* 4 4))       ;; Expansão
→ (+ 9 16)                  ;; Redução
→ 25                        ;; Redução e Encerramento
    </code></pre>

      <h4>Dois Estilos de Avaliação</h4>

      <p>
        O modelo de substituição permite visualizar dois estilos de avaliação:
      </p>

      <ul>
        <li>
          <strong>Avaliação Aplicativa (Applicative Order - "Eager"):</strong>
          Avalia primeiro os argumentos, depois substitui a função.
        </li>
        <li>
          <strong>Avaliação Normal (Normal Order - "Lazy"):</strong> A função é
          expandida antes da avaliação dos argumentos.
        </li>
      </ul>
      <h5>Comparação com código</h5>
      <pre><code class="language-scheme">
(define (square x)
(* x x))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; #Applicative Order - "Eager"
;; Exemplo 1: Cálculo desnecessário

(square (+ 3 4))     ;; Chamada
→ (square 7)         ;; Primeiro avaliamos (+ 3 4)
→ (* 7 7)            ;; Agora substituímos o corpo
→ 49                 ;; Reduzimos para o resultado final

;; Aqui, avaliar (+ 3 4) antes faz sentido, pois será usado na função.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; #Normal Order - "Lazy"
;; Exemplo 1: Cálculo adiado

(square (+ 3 4))       ;; Chamada
→ (* (+ 3 4) (+ 3 4))  ;; Primeiro substituímos a função sem avaliar os argumentos
→ (* 7 7)              ;; Agora avaliamos (+ 3 4), quando necessário
→ 49

;; Mesmo resultado, mas os argumentos foram avaliados apenas quando precisaram ser usados.
      </code></pre>
      <pre><code class="language-scheme">
(define (choose-first x y)
  x)  ;; Apenas retorna x, ignorando y

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; #Applicative Order - "Eager"
;; Exemplo 2: Avaliação desnecessária

(choose-first 3 (* 1000 1000))  
→ (choose-first 3 1000000)  ;; Avaliamos (* 1000 1000) primeiro (mesmo sem precisar!)
→ 3                         ;; Apenas retorna x, então o cálculo foi inútil!

;; Aqui, o cálculo (* 1000 1000) foi feito mesmo sem necessidade!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; #Normal Order - "Lazy"
;; Exemplo 2: Cálculo evitado

(choose-first 3 (* 1000 1000))  
→ 3  ;; Nunca avaliamos (* 1000 1000) porque o segundo argumento não foi usado!

;; Aqui, evitamos o cálculo desnecessário!
      </code></pre>
      <pre><code class="language-scheme">
;; Exemplo 3: Erro inevitável
(choose-first 3 (/ 1 0))  ;; #Normal Order - "Lazy"
→ (choose-first 3 ERRO)   ;; Avalia (/ 1 0) antes → erro!

;; Erro ocorre mesmo que y não seja usado!

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(choose-first 3 (/ 1 0))  ;; #Normal Order - "Lazy"
→ 3                       ;; Nunca avaliamos (/ 1 0), então evitamos o erro!

;; Aqui, evitamos o cálculo desnecessário!
      </code></pre>
      <hr />
      <h3>Exercícios</h3>
      <h4>Exercício 1.1:</h4>
      <p>
        Abaixo está uma sequência de expressões. Qual é o resultado impresso
        pelo interpretador em resposta a cada expressão? Suponha que a sequência
        seja avaliada na ordem em que é apresentada.
      </p>
      <pre><code class="language-scheme">
→ 10  ;; 10
→ 12  ;; (+ 5 3 4)
→ 8   ;; (- 9 1)
→ 3   ;; (/ 6 2)
→ 6   ;; (+ (* 2 4) (- 4 6))
      ;; (define a 3)
      ;; (define b (+ a 1))
→ 19  ;; (+ a b (* a b))
→ #f  ;; (= a b)
      ;; (if (and (> b a) (&lt; b (* a b)))
      ;;     b
→ 4   ;;     a)
      ;; (cond ((= a 4) 6)
      ;;       ((= b 4) (+ 6 7 a))
→ 16  ;;       (else 25))
→ 6   ;; (+ 2 (if (> b a) b a))
      ;; (* (cond ((> a b) a)
      ;;          ((&lt; a b) b)
      ;;          (else -1))
→ 16  ;;    (+ a 1))
      </code></pre>
      <h4>Exercício 1.2:</h4>
      <p>Traduza a seguinte expressão para a forma prefixa:</p>
      <pre><code class="language-scheme">
;; 5 + 4 + (2 - (3 - (6 + 4/5))) / 3(6-2)(2-7)

(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5)))))
   (* 3 (- 6 2) (- 2 7)))
      </code></pre>
      <h4>Exercício 1.3:</h4>
      <p>
        Defina um procedimento que receba três números como argumentos e retorne
        a soma dos quadrados dos dois maiores números.
      </p>
      <pre><code class="language-scheme">
(define (quadrado n)
  (* n n))

;; Solução 1
(define (maiores x y z)
  (if (or                     ;; x² + y²
        (and (= x y) (= y z)) ;; x = y = z {xy}
        (and (> y x) (> x z)) ;; y > x > z {xy}
        (and (> x y) (> y z)) ;; x > y > z {xy}
        (and (> y z) (= x y)) ;; x = y > z {xy}
      )
      (+ (quadrado x) (quadrado y))
      
  (if (or                     ;; z² + x²
        (and (> z x) (> x y))  ;; z > x > y {xz}
        (and (> x z) (>= z y)) ;; x > z > y {xz}
        (and (> x y) (= x z))  ;; z = x > y {xz}
      ) 
      (+ (quadrado z) (quadrado x))
      
  (if (or                     ;; z² + y²
        (and (> z y) (>= y x)) ;; z > y > x {yz}
        (and (> y z) (>= z x)) ;; y > z > x {yz}
        (and (> y x) (= z y))  ;; z = y > x {yz}
      )
            (+ (quadrado z) (quadrado y))
            -1))))

"Tudo diferente"
(maiores 1 2 3) 
(maiores 1 3 2) 
(maiores 2 1 3) 
(maiores 2 3 1) 
(maiores 3 1 2) 
(maiores 3 2 1) 
"Tudo igual"
(maiores 1 1 1) 
"Dois menores"
(maiores 2 1 1)
(maiores 1 2 1)
(maiores 1 1 2)
"Dois maiores"
(maiores 1 2 2) 
(maiores 2 1 2) 
(maiores 2 2 1) 
      </code></pre>
      <h4>Exercício 1.4:</h4>
      <p>
        Observe que nosso modelo de avaliação permite combinações cujos
        operadores são expressões compostas. Use essa observação para descrever
        o comportamento do seguinte procedimento:
      </p>
      <pre><code class="language-scheme">
;; (define (a-plus-abs-b a b)
;;  ((if (> b 0) + -) a b))

(a-plus-abs-b a b)    ;; Chamada
→ (                   ;; Expansão
→ (if (> b 0)         ;; Expansão {Se b > 0 então:
→     +               ;; + se não:
→     -)              ;; -}
→ a b)                ;; Sendo b &gt;  0 fica (+ a b)
                      ;; Sendo b &lt;= 0 fica (- a b)
      </code></pre>
      <h4>Exercício 1.5:</h4>
      <p>
        Ben Bitdiddle inventou um teste para determinar se o interpretador que
        ele enfrenta está usando avaliação em ordem aplicativa ou em ordem
        normal. Ele define os seguintes dois procedimentos:
      </p>
      <pre><code class="language-scheme">
(define (p) (p))

(define (test x y) 
   (if (= x 0) 
       0 
       y))
      </code></pre>
      <p>Então ele avalia a expressão:</p>
      <pre><code class="language-scheme">
(test 0 (p))

;; Resposta
→  if (#t)    ;; 0 = 0
→  0          ;; Resultado
;; y             Essa parte nunca é chamada
      </code></pre>
      <h4>Exercício 1.6:</h4>
      <p>
        Alyssa P. Hacker não entende por que
        <span class="code">if</span> precisa ser fornecido como uma forma
        especial. “Por que não posso simplesmente defini-lo como um procedimento
        ordinário em termos de <span class="code">cond?</span>”, ela pergunta. A
        amiga de Alyssa, Eva Lu Ator, afirma que isso pode ser feito, e ela
        define uma nova versão de <span class="code">if</span>:
      </p>
      <pre><code class="language-scheme">
(define (new-if predicate 
        then-clause 
        else-clause)
  (cond (predicate then-clause)
        (else else-clause)))
      </code></pre>
      <p>Eva demonstra o programa para Alyssa:</p>
      <pre><code class="language-scheme">
(new-if (= 2 3) 0 5)
5

(new-if (= 1 1) 0 5)
0
        </code></pre>
      <p>
        Encantada, Alyssa usa <span class="code">new-if</span> para reescrever o
        programa de raiz quadrada:
      </p>
      <pre><code class="language-scheme">
(define (sqrt-iter guess x)
  (new-if (good-enough? guess x)
          guess
          (sqrt-iter (improve guess x) x)))
        </code></pre>
      <p>
        O que acontece quando Alyssa tenta usar isso para calcular raízes
        quadradas? Explique.
      </p>
      <p class="exercise-answer">
        O <span class="code">if</span> é uma forma espécial que somente avalia
        <span class="code">else-clause</span> se o
        <span class="code">predicate</span>for falso, o
        <span class="code">new-if</span> torna possivel avaliar o
        <span class="code">else-clause</span> independente do
        <span class="code">predicate</span>criando um
        <span lang="en">loop</span> infinito ao chamar a função
        <span class="code">sqrt-iter</span> recursivamente.
      </p>
      <h4>Exercício 1.7:</h4>
      <p>
        O teste <span class="code">good-enough?</span> usado no cálculo de
        raízes quadradas não será muito eficaz para encontrar as raízes
        quadradas de números muito pequenos. Além disso, em computadores reais,
        as operações aritméticas são quase sempre realizadas com precisão
        limitada. Isso torna nosso teste inadequado para números muito grandes.
        Explique essas afirmações, com exemplos mostrando como o teste falha
        para números pequenos e grandes. Uma estratégia alternativa para
        implementar <span class="code">good-enough?</span> é observar como
        <span class="code">guess</span>
        muda de uma iteração para a próxima, e parar quando a mudança é uma
        fração muito pequena do palpite. Projete um procedimento de raiz
        quadrada que use esse tipo de teste final. Isso funciona melhor para
        números pequenos e grandes?
      </p>
      <ol class="exercise-answer">
        <li>
          O código estipula um diferença entre o palpite e a raiz de um milésimo
          (1/100 ou 0,001), isso limita o código a achar raizes que se enquadre
          nessa limitação.
        </li>
        <li>
          Quando os numeros são muito pequenos &mdash; proximos de 0 (zero)
          &mdash; a probabilidade de o retorno da raiz ser precoce por conta do
          ponto <em>1.</em> é grande. Exemplo: A raiz quadrada de 0.0001 é 0.01
          porém o código retorna 0.03230844833048122, uma diferença de
          0,02230844833048122 (≈ 69,05%).
        </li>
        <li>
          Agora quando com numeros muito grandes a situação <em>2.</em> também
          pode ser aplicada, porém só é relevante quando há casas decimeis em
          ordem de um décimo de milésimo (1/10000 ou 0,0001) de grandeza. Porém
          quando há números &gt;= quatorze casas décimais em minha maquina o
          código não retorna o resultado por falta de potência computacional.
        </li>
      </ol>
      <pre><code class="language-scheme">
;; Essa é a resposta
(define (good-enough? guess next-guess)
  (&lt;
    (abs (- guess next-guess ))
    (* guess 0.001))) ;; 0.1% de tolerância, poderia ser (/ guess 100)
;; A idéia é comparar o palpite novo com o antigo
;; caso a diferença for 1% então #t (true)

;; Restante do código para que a resposta funcione
(define (sqrt-iter guess x)
  ;; Com let crio uma variável local next-guess
  ;; para que entre como atributo em good-enough?
  ;; (let &lt;variavel&gt; &lt;valor&gt;) ou
  ;; (let (&lt;var1&gt; &lt;valor1&gt;) (&lt;var2&gt; &lt;valor2&gt;))
  (let ((next-guess (improve guess x))) ;; Acrescentei a linha
    (if (good-enough? guess next-guess) ;; Alterei os atributos
        next-guess                      ;; Alterei o retorno
        (sqrt-iter next-guess x))))     ;; Alterei o atributo

(define (improve guess x)
  (average guess (/ x guess)))

(define (average x y) 
  (/ (+ x y) 2))

(define (sqrt x)
  (sqrt-iter 1.0 x))

(sqrt 0.00001)
      </code></pre>
    </article>
    <script src="/js/buttonToTop.js"></script>
  </body>
</html>
